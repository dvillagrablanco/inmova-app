/**
 * Servicio de Cumplimiento Legal y Normativo
 * Gestiona CEE, ITE, Cédulas de Habitabilidad, Modelo 347/180
 */
import { prisma } from '@/lib/db';
import { addMonths, addYears, format, differenceInDays } from 'date-fns';
import { es } from 'date-fns/locale';

// ============ CERTIFICADO DE EFICIENCIA ENERGÉTICA (CEE) ============

export interface CreateCEEParams {
  unitId: string;
  companyId: string;
  calificacion: string; // A, B, C, D, E, F, G
  numeroCertificado: string;
  nombreTecnico: string;
  fechaEmision: Date;
  validezAnios?: number; // Por defecto 10 años
}

export async function registerEnergyCertificate(params: CreateCEEParams) {
  const validez = params.validezAnios || 10;
  const fechaVencimiento = addYears(params.fechaEmision, validez);

  return await prisma.energyCertificate.create({
    data: {
      unitId: params.unitId,
      companyId: params.companyId,
      calificacion: params.calificacion,
      numeroCertificado: params.numeroCertificado,
      nombreTecnico: params.nombreTecnico,
      fechaEmision: params.fechaEmision,
      fechaVencimiento,
      vigente: true,
    },
  });
}

export async function checkCEEExpirations(companyId: string, diasAnticipacion: number = 90) {
  const fechaLimite = addMonths(new Date(), 3); // 90 días por defecto

  const certificadosProximosVencer = await prisma.energyCertificate.findMany({
    where: {
      companyId,
      vigente: true,
      fechaVencimiento: { lte: fechaLimite, gte: new Date() },
    },
    include: {
      unit: {
        include: { building: true },
      },
    },
  });

  // Crear alertas automáticas
  for (const cert of certificadosProximosVencer) {
    const diasRestantes = differenceInDays(cert.fechaVencimiento, new Date());
    
    await prisma.notification.create({
      data: {
        companyId,
        userId: '', // TODO: Asignar al responsable
        tipo: 'alerta',
        titulo: `CEE próximo a vencer - ${cert.unit?.numero}`,
        mensaje: `El certificado energético de la unidad ${cert.unit?.numero} vence en ${diasRestantes} días`,
        leido: false,
        nivelRiesgo: diasRestantes < 30 ? 'alto' : 'medio',
      },
    });
  }

  return certificadosProximosVencer;
}

// ============ ITE (INSPECCIÓN TÉCNICA DE EDIFICIOS) ============

export interface CreateITEParams {
  buildingId: string;
  companyId: string;
  fechaInspeccion: Date;
  tecnicoResponsable: string;
  resultado: 'favorable' | 'favorable_condicional' | 'desfavorable';
  deficienciasEncontradas?: string[];
  recomendaciones?: string[];
  proximaInspeccion?: Date;
}

export async function registerBuildingInspection(params: CreateITEParams) {
  const inspection = await prisma.buildingInspection.create({
    data: {
      buildingId: params.buildingId,
      companyId: params.companyId,
      tipo: 'ITE',
      fechaInspeccion: params.fechaInspeccion,
      tecnicoResponsable: params.tecnicoResponsable,
      estado: params.resultado === 'favorable' ? 'completada' : 'pendiente_actuacion',
      resultado: params.resultado,
      deficienciasEncontradas: params.deficienciasEncontradas || [],
      recomendaciones: params.recomendaciones || [],
      proximaInspeccion: params.proximaInspeccion || addYears(params.fechaInspeccion, 5),
    },
  });

  // Si el resultado es desfavorable, crear notificación urgente
  if (params.resultado === 'desfavorable') {
    await prisma.notification.create({
      data: {
        companyId: params.companyId,
        userId: '',
        tipo: 'urgente',
        titulo: `ITE desfavorable - Edificio ${inspection.buildingId}`,
        mensaje: `La ITE ha resultado desfavorable. Se requieren actuaciones inmediatas.`,
        leido: false,
        nivelRiesgo: 'critico',
      },
    });
  }

  return inspection;
}

export async function getITECalendar(companyId: string) {
  const edificios = await prisma.building.findMany({
    where: { companyId },
    include: {
      inspections: {
        where: { tipo: 'ITE' },
        orderBy: { fechaInspeccion: 'desc' },
        take: 1,
      },
    },
  });

  return edificios.map(edificio => {
    const ultimaITE = edificio.inspections[0];
    const antiguedad = new Date().getFullYear() - new Date(edificio.fechaConstruccion || new Date()).getFullYear();

    // Determinar periodicidad según antigüedad
    let periodicidadAnios = 10;
    if (antiguedad > 50) periodicidadAnios = 5;
    else if (antiguedad > 30) periodicidadAnios = 7;

    const proximaITE = ultimaITE?.proximaInspeccion || addYears(new Date(), periodicidadAnios);
    const diasHasta = differenceInDays(proximaITE, new Date());

    return {
      edificio: edificio.nombre,
      edificioId: edificio.id,
      ultimaITE: ultimaITE?.fechaInspeccion,
      proximaITE,
      diasHasta,
      urgencia: diasHasta < 90 ? 'alta' : diasHasta < 180 ? 'media' : 'baja',
    };
  });
}

// ============ CÉDULAS DE HABITABILIDAD ============

export interface CreateHabitabilityParams {
  unitId: string;
  companyId: string;
  numeroCedula: string;
  fechaEmision: Date;
  ccaa: string; // Comunidad Autónoma
  validezAnios?: number;
}

export async function registerHabitabilityCertificate(params: CreateHabitabilityParams) {
  const validez = params.validezAnios || 15; // Varía según CCAA
  const fechaVencimiento = addYears(params.fechaEmision, validez);

  return await prisma.habitabilityCertificate.create({
    data: {
      unitId: params.unitId,
      companyId: params.companyId,
      numeroCedula: params.numeroCedula,
      fechaEmision: params.fechaEmision,
      fechaVencimiento,
      ccaa: params.ccaa,
      estado: 'vigente',
      alertaEnviada: false,
    },
  });
}

// ============ MODELO 347 (HACIENDA) ============

export interface GenerateModelo347Params {
  companyId: string;
  ejercicio: number; // Año fiscal
}

export async function generateModelo347(params: GenerateModelo347Params) {
  const inicioEjercicio = new Date(params.ejercicio, 0, 1);
  const finEjercicio = new Date(params.ejercicio, 11, 31);

  // Obtener todas las operaciones del ejercicio
  const pagosRecibidos = await prisma.payment.findMany({
    where: {
      contract: { building: { companyId: params.companyId } },
      estado: 'pagado',
      fechaPago: { gte: inicioEjercicio, lte: finEjercicio },
    },
    include: {
      contract: {
        include: { tenant: true },
      },
    },
  });

  const gastosRealizados = await prisma.expense.findMany({
    where: {
      building: { companyId: params.companyId },
      fecha: { gte: inicioEjercicio, lte: finEjercicio },
    },
    include: {
      provider: true,
    },
  });

  const records = [];

  // Agrupar pagos por inquilino (solo si superan 3.005,06€)
  const pagosPorInquilino = pagosRecibidos.reduce((acc: any, pago) => {
    const tenantId = pago.contract.tenantId;
    if (!acc[tenantId]) {
      acc[tenantId] = {
        tenant: pago.contract.tenant,
        total: 0,
        operaciones: 0,
      };
    }
    acc[tenantId].total += pago.monto;
    acc[tenantId].operaciones++;
    return acc;
  }, {});

  for (const [tenantId, data] of Object.entries(pagosPorInquilino as any)) {
    if (data.total > 3005.06) {
      const record = await prisma.modelo347Record.create({
        data: {
          companyId: params.companyId,
          ejercicio: params.ejercicio,
          nifDeclarado: data.tenant.dni || '',
          nombreDeclarado: data.tenant.nombreCompleto,
          tipoOperacion: 'ingreso',
          importeAnual: data.total,
          numeroOperaciones: data.operaciones,
          trimestre: null, // Anual
        },
      });
      records.push(record);
    }
  }

  // Agrupar gastos por proveedor
  const gastosPorProveedor = gastosRealizados.reduce((acc: any, gasto) => {
    const providerId = gasto.providerId;
    if (!providerId || !gasto.provider) return acc;

    if (!acc[providerId]) {
      acc[providerId] = {
        provider: gasto.provider,
        total: 0,
        operaciones: 0,
      };
    }
    acc[providerId].total += gasto.monto;
    acc[providerId].operaciones++;
    return acc;
  }, {});

  for (const [providerId, data] of Object.entries(gastosPorProveedor as any)) {
    if (data.total > 3005.06) {
      const record = await prisma.modelo347Record.create({
        data: {
          companyId: params.companyId,
          ejercicio: params.ejercicio,
          nifDeclarado: data.provider.cif || '',
          nombreDeclarado: data.provider.nombre,
          tipoOperacion: 'gasto',
          importeAnual: data.total,
          numeroOperaciones: data.operaciones,
          trimestre: null,
        },
      });
      records.push(record);
    }
  }

  return {
    ejercicio: params.ejercicio,
    totalRegistros: records.length,
    registros: records,
  };
}

// ============ MODELO 180 (RETENCIONES NO RESIDENTES) ============

export interface GenerateModelo180Params {
  companyId: string;
  trimestre: number; // 1, 2, 3, 4
  ejercicio: number;
}

export async function generateModelo180(params: GenerateModelo180Params) {
  const inicioTrimestre = new Date(params.ejercicio, (params.trimestre - 1) * 3, 1);
  const finTrimestre = new Date(params.ejercicio, params.trimestre * 3, 0);

  // Buscar contratos con inquilinos no residentes
  const contratos = await prisma.contract.findMany({
    where: {
      building: { companyId: params.companyId },
      estado: 'activo',
      fechaInicio: { lte: finTrimestre },
      OR: [
        { fechaFin: { gte: inicioTrimestre } },
        { fechaFin: null },
      ],
    },
    include: {
      tenant: true,
      payments: {
        where: {
          estado: 'pagado',
          fechaPago: { gte: inicioTrimestre, lte: finTrimestre },
        },
      },
    },
  });

  const records = [];
  const tipoRetencion = 0.24; // 24% para no residentes sin convenio

  for (const contrato of contratos) {
    // Verificar si el inquilino es no residente (simplificado)
    const esNoResidente = contrato.tenant.email?.includes('@') && !contrato.tenant.dni;

    if (esNoResidente && contrato.payments.length > 0) {
      const baseImponible = contrato.payments.reduce((sum, p) => sum + p.monto, 0);
      const retencion = baseImponible * tipoRetencion;

      const record = await prisma.modelo180Record.create({
        data: {
          companyId: params.companyId,
          ejercicio: params.ejercicio,
          trimestre: params.trimestre,
          nifArrendatario: contrato.tenant.pasaporte || 'N/A',
          nombreArrendatario: contrato.tenant.nombreCompleto,
          paisResidencia: 'Desconocido', // TODO: Añadir campo en tenant
          baseImponible,
          tipoRetencion: tipoRetencion * 100,
          importeRetenido: retencion,
        },
      });

      records.push(record);
    }
  }

  return {
    trimestre: params.trimestre,
    ejercicio: params.ejercicio,
    totalRegistros: records.length,
    totalRetenido: records.reduce((sum, r) => sum + r.importeRetenido, 0),
    registros: records,
  };
}

// ============ REGISTRO DE CONTRATOS EN CCAA ============

export async function registerContractInCCAA(contractId: string, ccaa: string) {
  // Cataluña requiere registro obligatorio de contratos
  if (ccaa === 'Cataluña' || ccaa === 'Catalunya') {
    const contrato = await prisma.contract.findUnique({
      where: { id: contractId },
      include: {
        tenant: true,
        unit: { include: { building: true } },
      },
    });

    if (!contrato) throw new Error('Contrato no encontrado');

    // TODO: Integración con servicio de la Generalitat
    // Por ahora, solo registramos localmente que se debe hacer

    return {
      registroRequerido: true,
      ccaa,
      plazo: '30 días desde la firma',
      enlaceRegistro: 'https://habitatge.gencat.cat',
      contratoId: contractId,
    };
  }

  return {
    registroRequerido: false,
    ccaa,
  };
}
