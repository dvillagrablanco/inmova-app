/**
 * Servicio de Gestión de Comunidades de Vecinos
 * Gestiona actas, cuotas, fondos, votaciones telemáticas
 */
import { prisma } from '@/lib/db';
import { ActaEstado, CuotaTipo, FondoTipo, VotacionEstado, VotacionTipo } from '@prisma/client';
import { addMonths, format } from 'date-fns';
import { es } from 'date-fns/locale';

// ============ GESTIÓN DE ACTAS DIGITALES ============

export interface CreateMinuteParams {
  buildingId: string;
  companyId: string;
  fecha: Date;
  asistentes: string[];
  orden: string[];
  acuerdos: string[];
  proximaConvocatoria?: Date;
  creadoPor: string;
}

export async function createCommunityMinute(params: CreateMinuteParams) {
  const minute = await prisma.communityMinute.create({
    data: {
      buildingId: params.buildingId,
      companyId: params.companyId,
      fecha: params.fecha,
      asistentes: params.asistentes,
      ordenDia: params.orden,
      acuerdos: params.acuerdos,
      proximaConvocatoria: params.proximaConvocatoria,
      estado: 'borrador' as ActaEstado,
      creadoPor: params.creadoPor,
    },
    include: {
      building: true,
    },
  });

  return minute;
}

export async function signMinute(minuteId: string, userId: string, firmaDigital: string) {
  return await prisma.communityMinute.update({
    where: { id: minuteId },
    data: {
      firmantes: {
        push: userId,
      },
      firmasDigitales: {
        push: firmaDigital,
      },
      estado: 'aprobada' as ActaEstado,
    },
  });
}

// ============ GESTIÓN DE CUOTAS DE COMUNIDAD ============

export interface GenerateFeesParams {
  buildingId: string;
  companyId: string;
  periodo: string; // '2024-01'
  tipo: CuotaTipo;
  montoPorUnidad?: number;
}

export async function generateCommunityFees(params: GenerateFeesParams) {
  const units = await prisma.unit.findMany({
    where: { buildingId: params.buildingId },
    include: { contracts: { where: { estado: 'activo' }, take: 1 } },
  });

  const fees = [];
  for (const unit of units) {
    // Calcular monto basado en coeficiente o distribución equitativa
    const monto = params.montoPorUnidad || 50; // Monto base si no se especifica

    const fee = await prisma.communityFee.create({
      data: {
        buildingId: params.buildingId,
        companyId: params.companyId,
        unitId: unit.id,
        tipo: params.tipo,
        periodo: params.periodo,
        monto,
        pagado: false,
        fechaVencimiento: addMonths(new Date(), 1),
      },
    });

    fees.push(fee);
  }

  return fees;
}

export async function markFeeAsPaid(feeId: string, fechaPago: Date, metodoPago: string) {
  return await prisma.communityFee.update({
    where: { id: feeId },
    data: {
      pagado: true,
      fechaPago,
      metodoPago,
    },
  });
}

export async function getCommunityFeesByBuilding(buildingId: string, periodo?: string) {
  return await prisma.communityFee.findMany({
    where: {
      buildingId,
      ...(periodo && { periodo }),
    },
    include: {
      unit: true,
    },
    orderBy: { createdAt: 'desc' },
  });
}

// ============ GESTIÓN DE FONDOS DE RESERVA ============

export interface CreateFundParams {
  buildingId: string;
  companyId: string;
  tipo: FondoTipo;
  nombre: string;
  saldoActual: number;
  objetivo?: number;
}

export async function createCommunityFund(params: CreateFundParams) {
  return await prisma.communityFund.create({
    data: {
      buildingId: params.buildingId,
      companyId: params.companyId,
      tipo: params.tipo,
      nombre: params.nombre,
      saldoActual: params.saldoActual,
      objetivo: params.objetivo,
      movimientos: [],
    },
    include: {
      building: true,
    },
  });
}

export async function addFundMovement(
  fundId: string,
  tipo: 'ingreso' | 'gasto',
  monto: number,
  concepto: string
) {
  const fund = await prisma.communityFund.findUnique({ where: { id: fundId } });
  if (!fund) throw new Error('Fondo no encontrado');

  const nuevoSaldo = tipo === 'ingreso' 
    ? fund.saldoActual + monto 
    : fund.saldoActual - monto;

  const movimiento = {
    fecha: new Date().toISOString(),
    tipo,
    monto,
    concepto,
    saldoResultante: nuevoSaldo,
  };

  return await prisma.communityFund.update({
    where: { id: fundId },
    data: {
      saldoActual: nuevoSaldo,
      movimientos: {
        push: movimiento,
      },
    },
  });
}

// ============ VOTACIONES TELEMÁTICAS ============

export interface CreateVotingParams {
  buildingId: string;
  companyId: string;
  titulo: string;
  descripcion: string;
  opciones: string[];
  fechaInicio: Date;
  fechaFin: Date;
  tipo: VotacionTipo;
  totalElegibles: number;
  creadoPor: string;
}

export async function createVoting(params: CreateVotingParams) {
  return await prisma.communityVote.create({
    data: {
      buildingId: params.buildingId,
      companyId: params.companyId,
      titulo: params.titulo,
      descripcion: params.descripcion,
      opciones: params.opciones,
      fechaInicio: params.fechaInicio,
      fechaFin: params.fechaFin,
      tipo: params.tipo,
      estado: 'pendiente' as VotacionEstado,
      totalElegibles: params.totalElegibles,
      totalVotantes: 0,
      resultados: {},
      creadoPor: params.creadoPor,
    },
  });
}

export async function castVote(voteId: string, tenantId: string, opcion: string) {
  const voting = await prisma.communityVote.findUnique({
    where: { id: voteId },
    include: { voteRecords: true },
  });

  if (!voting) throw new Error('Votación no encontrada');
  if (voting.estado !== 'activa') throw new Error('Votación no está activa');

  // Verificar si ya votó
  const yaVoto = voting.voteRecords.some(r => r.tenantId === tenantId);
  if (yaVoto) throw new Error('Ya has votado en esta votación');

  // Registrar voto
  await prisma.voteRecord.create({
    data: {
      voteId,
      tenantId,
      opcionElegida: opcion,
    },
  });

  // Actualizar resultados
  const resultados = voting.resultados as any || {};
  resultados[opcion] = (resultados[opcion] || 0) + 1;

  const totalVotantes = voting.totalVotantes + 1;

  // Verificar si se alcanzó el quorum
  let opcionGanadora;
  let estado = voting.estado;

  if (totalVotantes === voting.totalElegibles) {
    estado = 'cerrada';
    opcionGanadora = Object.keys(resultados).reduce((a, b) => 
      resultados[a] > resultados[b] ? a : b
    );
  }

  return await prisma.communityVote.update({
    where: { id: voteId },
    data: {
      totalVotantes,
      resultados,
      estado,
      opcionGanadora,
    },
  });
}

export async function getVotingResults(voteId: string) {
  const voting = await prisma.communityVote.findUnique({
    where: { id: voteId },
    include: {
      voteRecords: true,
    },
  });

  if (!voting) throw new Error('Votación no encontrada');

  return {
    voting,
    participacion: (voting.totalVotantes / voting.totalElegibles) * 100,
    resultados: voting.resultados,
    opcionGanadora: voting.opcionGanadora,
  };
}
