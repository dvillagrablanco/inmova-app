/**
 * Servicio de Open Banking
 * Modo Demo + Preparado para integraci√≥n con Plaid/Tink
 */

import { prisma } from './db';

// Estados de las conexiones bancarias
export enum EstadoConexion {
  ACTIVA = 'activa',
  DESCONECTADA = 'desconectada',
  ERROR = 'error',
  PENDIENTE = 'pendiente'
}

// Tipos de transacciones
export enum TipoTransaccion {
  CREDITO = 'credito',
  DEBITO = 'debito'
}

/**
 * MODO DEMO: Conecta una cuenta bancaria simulada
 * En producci√≥n: Usar Plaid Link o Tink Connect
 */
export async function conectarCuentaBancaria(params: {
  tenantId: string;
  companyId: string;
  nombreBanco: string;
  tipoCuenta: string;
  nombreTitular: string;
}) {
  const { tenantId, companyId, nombreBanco, tipoCuenta, nombreTitular } = params;

  try {
    // MODO DEMO: Generar IDs simulados
    const plaidAccessToken = `DEMO_TOKEN_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const plaidItemId = `DEMO_ITEM_${Date.now()}`;
    const cuentaExterna = `****${Math.floor(1000 + Math.random() * 9000)}`;

    // Crear la conexi√≥n bancaria
    const connection = await prisma.bankConnection.create({
      data: {
        companyId,
        tenantId,
        plaidAccessToken, // En modo demo, token simulado
        plaidItemId,     // En modo demo, ID simulado
        nombreBanco,
        tipoCuenta,
        numeroUltimosDigitos: cuentaExterna.slice(-4),
        nombreTitular,
        saldoActual: Math.random() * 10000, // Saldo simulado
        moneda: 'EUR',
        estado: EstadoConexion.ACTIVA,
        ultimaSincronizacion: new Date(),
        metadatos: {
          demo: true,
          simulado: true
        }
      }
    });

    console.log(`üè¶ [MODO DEMO] Cuenta bancaria conectada: ${nombreBanco} - ${cuentaExterna}`);

    /*
    // EN PRODUCCI√ìN: Integrar con Plaid
    const plaidClient = new PlaidApi(plaidConfig);
    
    // Intercambiar public_token por access_token
    const response = await plaidClient.itemPublicTokenExchange({
      public_token: publicToken
    });

    const accessToken = response.data.access_token;
    const itemId = response.data.item_id;

    // Obtener informaci√≥n de las cuentas
    const accountsResponse = await plaidClient.accountsGet({
      access_token: accessToken
    });

    const account = accountsResponse.data.accounts[0];

    // Crear conexi√≥n con datos reales
    const connection = await prisma.bankConnection.create({
      data: {
        companyId,
        tenantId,
        plaidAccessToken: accessToken,
        plaidItemId: itemId,
        nombreBanco: account.institution_id,
        tipoCuenta: account.type,
        numeroUltimosDigitos: account.mask,
        nombreTitular: nombreTitular,
        saldoActual: account.balances.current,
        moneda: account.balances.iso_currency_code,
        estado: EstadoConexion.ACTIVA,
        metadatos: {
          plaidAccountId: account.account_id
        }
      }
    });
    */

    return {
      success: true,
      connection,
      message: '[MODO DEMO] Cuenta bancaria conectada (simulado)'
    };
  } catch (error) {
    console.error('Error conectando cuenta bancaria:', error);
    throw error;
  }
}

/**
 * MODO DEMO: Sincroniza transacciones bancarias simuladas
 * En producci√≥n: Sincronizar con Plaid/Tink
 */
export async function sincronizarTransacciones(connectionId: string) {
  try {
    const connection = await prisma.bankConnection.findUnique({
      where: { id: connectionId }
    });

    if (!connection) {
      throw new Error('Conexi√≥n bancaria no encontrada');
    }

    // MODO DEMO: Generar transacciones simuladas
    const transaccionesSimuladas = generarTransaccionesDemo(connection.id);

    // Guardar transacciones
    const transacciones = await Promise.all(
      transaccionesSimuladas.map(t =>
        prisma.bankTransaction.create({
          data: {
            bankConnectionId: connection.id,
            ...t
          }
        })
      )
    );

    // Actualizar √∫ltima sincronizaci√≥n
    await prisma.bankConnection.update({
      where: { id: connectionId },
      data: {
        ultimaSincronizacion: new Date()
      }
    });

    console.log(`üí≥ [MODO DEMO] ${transacciones.length} transacciones sincronizadas`);

    /*
    // EN PRODUCCI√ìN: Sincronizar con Plaid
    const plaidClient = new PlaidApi(plaidConfig);
    
    const response = await plaidClient.transactionsGet({
      access_token: connection.plaidAccessToken,
      start_date: lastSync,
      end_date: today
    });

    // Guardar transacciones reales
    for (const transaction of response.data.transactions) {
      await prisma.bankTransaction.upsert({
        where: { plaidTransactionId: transaction.transaction_id },
        create: {
          bankConnectionId: connection.id,
          plaidTransactionId: transaction.transaction_id,
          fecha: new Date(transaction.date),
          descripcion: transaction.name,
          monto: transaction.amount,
          tipo: transaction.amount > 0 ? TipoTransaccion.DEBITO : TipoTransaccion.CREDITO,
          categoria: transaction.category?.join(' > '),
          comerciante: transaction.merchant_name,
          metadatos: transaction
        },
        update: {}
      });
    }
    */

    return {
      success: true,
      transacciones,
      message: `[MODO DEMO] ${transacciones.length} transacciones sincronizadas`
    };
  } catch (error) {
    console.error('Error sincronizando transacciones:', error);
    throw error;
  }
}

/**
 * Genera transacciones demo para simulaci√≥n
 */
function generarTransaccionesDemo(connectionId: string) {
  const transacciones = [];
  const hoy = new Date();

  // Generar 10 transacciones de los √∫ltimos 30 d√≠as
  for (let i = 0; i < 10; i++) {
    const diasAtras = Math.floor(Math.random() * 30);
    const fecha = new Date(hoy);
    fecha.setDate(fecha.getDate() - diasAtras);

    const esCredito = Math.random() > 0.3;
    const monto = esCredito 
      ? Math.random() * 2000 + 500  // Ingresos: 500-2500
      : -(Math.random() * 500 + 50); // Gastos: -50 a -550

    const categorias = esCredito 
      ? ['Salario', 'Transferencia', 'Dep√≥sito', 'Reembolso']
      : ['Supermercado', 'Restaurante', 'Transporte', 'Servicios', 'Compras'];

    const categoria = categorias[Math.floor(Math.random() * categorias.length)];

    transacciones.push({
      fecha,
      descripcion: `${categoria} - Demo ${i + 1}`,
      monto,
      tipo: esCredito ? TipoTransaccion.CREDITO : TipoTransaccion.DEBITO,
      categoria,
      comerciante: `Comercio Demo ${i + 1}`,
      metadatos: {
        demo: true,
        simulado: true
      }
    });
  }

  return transacciones;
}

/**
 * MODO DEMO: Verifica ingresos de un inquilino
 * En producci√≥n: Analizar transacciones reales
 */
export async function verificarIngresos(tenantId: string) {
  try {
    // Obtener conexiones bancarias del inquilino
    const conexiones = await prisma.bankConnection.findMany({
      where: {
        tenantId,
        estado: EstadoConexion.ACTIVA
      },
      include: {
        transacciones: {
          where: {
            tipo: TipoTransaccion.CREDITO,
            fecha: {
              gte: new Date(new Date().setMonth(new Date().getMonth() - 3)) // √öltimos 3 meses
            }
          },
          orderBy: {
            fecha: 'desc'
          }
        }
      }
    });

    if (conexiones.length === 0) {
      throw new Error('No hay cuentas bancarias conectadas');
    }

    // Calcular ingresos promedio
    const todasTransacciones = conexiones.flatMap(c => c.transacciones);
    const ingresosMensuales = calcularIngresosMensuales(todasTransacciones);

    // MODO DEMO: Generar informe simulado
    const informe = {
      tenantId,
      fechaVerificacion: new Date(),
      ingresosPromedio: ingresosMensuales.promedio,
      ingresosMinimos: ingresosMensuales.minimo,
      ingresosMaximos: ingresosMensuales.maximo,
      estabilidad: calcularEstabilidadIngresos(ingresosMensuales.meses),
      fuentesIngresos: identificarFuentesIngresos(todasTransacciones),
      recomendacion: generarRecomendacionIngresos(ingresosMensuales.promedio),
      verificado: true
    };

    console.log(`üí∞ [MODO DEMO] Ingresos verificados: ‚Ç¨${informe.ingresosPromedio.toFixed(2)}/mes`);

    return {
      success: true,
      informe,
      message: '[MODO DEMO] Ingresos verificados (simulado)'
    };
  } catch (error) {
    console.error('Error verificando ingresos:', error);
    throw error;
  }
}

/**
 * Calcula ingresos mensuales
 */
function calcularIngresosMensuales(transacciones: any[]) {
  const ingresosPorMes: Record<string, number> = {};

  transacciones.forEach(t => {
    const mes = `${t.fecha.getFullYear()}-${String(t.fecha.getMonth() + 1).padStart(2, '0')}`;
    ingresosPorMes[mes] = (ingresosPorMes[mes] || 0) + Math.abs(t.monto);
  });

  const ingresos = Object.values(ingresosPorMes);
  const promedio = ingresos.reduce((a, b) => a + b, 0) / ingresos.length || 0;
  const minimo = Math.min(...ingresos);
  const maximo = Math.max(...ingresos);

  return {
    promedio,
    minimo,
    maximo,
    meses: Object.keys(ingresosPorMes).length
  };
}

/**
 * Calcula estabilidad de ingresos (0-100)
 */
function calcularEstabilidadIngresos(meses: number): number {
  // M√°s meses = m√°s estabilidad
  return Math.min(100, meses * 10 + Math.random() * 30);
}

/**
 * Identifica fuentes de ingresos
 */
function identificarFuentesIngresos(transacciones: any[]): string[] {
  const fuentes = new Set<string>();
  
  transacciones.forEach(t => {
    if (t.categoria && t.monto > 0) {
      fuentes.add(t.categoria);
    }
  });

  return Array.from(fuentes);
}

/**
 * Genera recomendaci√≥n basada en ingresos
 */
function generarRecomendacionIngresos(ingresos: number): string {
  if (ingresos > 3000) {
    return 'Excelente capacidad de pago. Ingresos muy estables.';
  } else if (ingresos > 2000) {
    return 'Buena capacidad de pago. Ingresos estables.';
  } else if (ingresos > 1500) {
    return 'Capacidad de pago aceptable. Revisar ratio renta/ingresos.';
  } else {
    return 'Ingresos limitados. Se recomienda avalista o garant√≠a adicional.';
  }
}

/**
 * Conciliar pagos con transacciones bancarias
 */
export async function conciliarPagos(companyId: string) {
  try {
    // Obtener pagos pendientes
    const pagosPendientes = await prisma.payment.findMany({
      where: {
        contract: {
          unit: {
            building: {
              companyId
            }
          }
        },
        estado: 'pendiente'
      },
      include: {
        contract: {
          include: {
            tenant: {
              include: {
                bankConnections: {
                  where: {
                    estado: EstadoConexion.ACTIVA
                  },
                  include: {
                    transacciones: {
                      where: {
                        tipo: TipoTransaccion.DEBITO,
                        reconciliado: false
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    });

    const conciliaciones = [];

    // MODO DEMO: Intentar conciliar
    for (const pago of pagosPendientes) {
      const conexiones = pago.contract.tenant.bankConnections || [];
      
      for (const conexion of conexiones) {
        const transaccionCandidato = conexion.transacciones.find(t => 
          Math.abs(Math.abs(t.monto) - pago.monto) < 1 && // Diferencia menor a ‚Ç¨1
          Math.abs(t.fecha.getTime() - pago.fechaVencimiento.getTime()) < 7 * 24 * 60 * 60 * 1000 // Dentro de 7 d√≠as
        );

        if (transaccionCandidato) {
          conciliaciones.push({
            pago,
            transaccion: transaccionCandidato,
            confidence: 0.95 // Demo
          });
        }
      }
    }

    console.log(`üîÑ [MODO DEMO] ${conciliaciones.length} conciliaciones encontradas`);

    return {
      success: true,
      conciliaciones,
      message: `[MODO DEMO] ${conciliaciones.length} pagos conciliados`
    };
  } catch (error) {
    console.error('Error conciliando pagos:', error);
    throw error;
  }
}
