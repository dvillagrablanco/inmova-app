/**
 * Servicio de Tesorería Avanzada
 * Gestiona cash flow, fianzas, provisiones de impagos, reconciliación bancaria
 */
import { prisma } from '@/lib/db';
import { addMonths, format, subMonths, startOfMonth, endOfMonth } from 'date-fns';
import { es } from 'date-fns/locale';

// ============ PREVISIÓN DE CASH FLOW ============

export interface CashFlowForecastParams {
  companyId: string;
  mesesAdelante?: number; // Por defecto 6-12 meses
}

export async function generateCashFlowForecast(params: CashFlowForecastParams) {
  const meses = params.mesesAdelante || 6;
  const forecasts = [];

  for (let i = 0; i < meses; i++) {
    const mes = addMonths(new Date(), i);
    const mesStr = format(mes, 'yyyy-MM');

    // Calcular ingresos esperados (contratos activos)
    const ingresosEsperados = await calcularIngresosEsperados(params.companyId, mes);

    // Calcular gastos esperados (promedio histórico + contratos fijos)
    const gastosEsperados = await calcularGastosEsperados(params.companyId, mes);

    // Saldo proyectado
    const saldoFinal = ingresosEsperados - gastosEsperados;

    const forecast = await prisma.cashFlowForecast.create({
      data: {
        companyId: params.companyId,
        mes: mesStr,
        ingresosPrevistos: ingresosEsperados,
        ingresosRecurrentes: ingresosEsperados * 0.8,
        ingresosVariables: ingresosEsperados * 0.2,
        gastosPrevistos: gastosEsperados,
        gastosRecurrentes: gastosEsperados * 0.7,
        gastosVariables: gastosEsperados * 0.3,
        saldoFinal,
      },
    });

    forecasts.push(forecast);
  }

  return forecasts;
}

async function calcularIngresosEsperados(companyId: string, mes: Date) {
  const contratos = await prisma.contract.findMany({
    where: {
      building: { companyId },
      estado: 'activo',
      fechaInicio: { lte: mes },
      OR: [
        { fechaFin: { gte: mes } },
        { fechaFin: null },
      ],
    },
  });

  return contratos.reduce((sum, c) => sum + (c.rentaMensual || 0), 0);
}

async function calcularGastosEsperados(companyId: string, mes: Date) {
  // Calcular promedio de gastos de los últimos 3 meses
  const tresMesesAtras = subMonths(mes, 3);
  
  const gastos = await prisma.expense.findMany({
    where: {
      buildingId: { in: [] }, // Simplificado - necesitaría obtener buildingIds de la compañía
      fecha: { gte: tresMesesAtras, lte: mes },
    },
  });

  const promedioGastos = gastos.length > 0
    ? gastos.reduce((sum, g) => sum + g.monto, 0) / 3
    : 0;

  return promedioGastos;
}

function calcularConfianza(mesesAdelante: number): number {
  // Confianza disminuye con el tiempo
  return Math.max(50, 95 - (mesesAdelante * 5));
}

// ============ GESTIÓN DE FIANZAS (CUENTAS DE DEPÓSITO) ============

export interface DepositManagementParams {
  contractId: string;
  monto: number;
  cuentaDeposito: string;
  numeroRegistro?: string;
}

export async function registerDeposit(params: DepositManagementParams) {
  const contrato = await prisma.contract.findUnique({
    where: { id: params.contractId },
    include: { building: true },
  });

  if (!contrato) throw new Error('Contrato no encontrado');

  return await prisma.depositManagement.create({
    data: {
      contractId: params.contractId,
      companyId: contrato.building.companyId,
      monto: params.monto,
      fechaDeposito: new Date(),
      cuentaDeposito: params.cuentaDeposito,
      numeroRegistro: params.numeroRegistro,
      estado: 'depositado',
    },
  });
}

export async function returnDeposit(depositId: string, montoDevuelto: number, deducciones: any[]) {
  const montoRetenido = deducciones.reduce((sum, d) => sum + d.monto, 0);

  return await prisma.depositManagement.update({
    where: { id: depositId },
    data: {
      estado: 'devuelto',
      fechaDevolucion: new Date(),
      montoDevuelto,
      montoRetenido,
      deducciones,
    },
  });
}

// ============ PROVISIÓN AUTOMÁTICA DE IMPAGOS ============

export interface BadDebtProvisionParams {
  companyId: string;
}

export async function calculateBadDebtProvisions(params: BadDebtProvisionParams) {
  const pagos = await prisma.payment.findMany({
    where: {
      contract: { building: { companyId: params.companyId } },
      estado: 'pendiente',
    },
    include: {
      contract: {
        include: {
          tenant: true,
          building: true,
        },
      },
    },
  });

  const provisions = [];

  for (const pago of pagos) {
    const diasVencido = Math.floor(
      (new Date().getTime() - pago.fechaVencimiento.getTime()) / (1000 * 60 * 60 * 24)
    );

    if (diasVencido <= 0) continue; // No vencido

    // Calcular porcentaje de provisión según antigüedad
    let porcentajeProvision = 0;
    let nivelRiesgo: 'bajo' | 'medio' | 'alto' | 'critico' = 'bajo';

    if (diasVencido <= 30) {
      porcentajeProvision = 10;
      nivelRiesgo = 'bajo';
    } else if (diasVencido <= 60) {
      porcentajeProvision = 25;
      nivelRiesgo = 'medio';
    } else if (diasVencido <= 90) {
      porcentajeProvision = 50;
      nivelRiesgo = 'alto';
    } else {
      porcentajeProvision = 100;
      nivelRiesgo = 'critico';
    }

    const montoProvision = pago.monto * (porcentajeProvision / 100);

    const provision = await prisma.badDebtProvision.upsert({
      where: { paymentId: pago.id },
      create: {
        paymentId: pago.id,
        companyId: params.companyId,
        montoOriginal: pago.monto,
        diasVencido,
        porcentajeProvision,
        montoProvision,
        nivelRiesgo,
        estadoRecuperacion: 'pendiente',
      },
      update: {
        diasVencido,
        porcentajeProvision,
        montoProvision,
        nivelRiesgo,
      },
    });

    provisions.push(provision);
  }

  return provisions;
}

// ============ ALERTAS DE DESCUADRES CONTABLES ============

export interface GenerateFinancialAlertsParams {
  companyId: string;
}

export async function generateFinancialAlerts(params: GenerateFinancialAlertsParams) {
  const alerts = [];

  // Alerta 1: Pagos vencidos > 30 días
  const pagosVencidos = await prisma.payment.count({
    where: {
      contract: { building: { companyId: params.companyId } },
      estado: 'pendiente',
      fechaVencimiento: { lte: subMonths(new Date(), 1) },
    },
  });

  if (pagosVencidos > 0) {
    alerts.push(await createAlert({
      companyId: params.companyId,
      tipo: 'morosidad',
      nivel: pagosVencidos > 5 ? 'alto' : 'medio',
      titulo: `${pagosVencidos} pagos vencidos hace más de 30 días`,
      descripcion: `Hay ${pagosVencidos} pagos pendientes con más de 30 días de retraso. Recomendamos revisar y tomar medidas de recobro.`,
    }));
  }

  // Alerta 2: Cash flow negativo proyectado
  const cashFlowProximo = await prisma.cashFlowForecast.findFirst({
    where: {
      companyId: params.companyId,
      saldoFinal: { lt: 0 },
    },
    orderBy: { mes: 'asc' },
  });

  if (cashFlowProximo) {
    alerts.push(await createAlert({
      companyId: params.companyId,
      tipo: 'cashflow',
      nivel: 'alto',
      titulo: `Cash flow negativo proyectado en ${cashFlowProximo.mes}`,
      descripcion: `Se proyecta un déficit de €${Math.abs(cashFlowProximo.saldoFinal).toFixed(2)} para ${cashFlowProximo.mes}. Considere ajustar gastos o buscar financiación.`,
    }));
  }

  // Alerta 3: Fianzas próximas a vencer sin registrar devolución
  const fianzasVencer = await prisma.depositManagement.findMany({
    where: {
      companyId: params.companyId,
      estado: 'depositado',
      contract: {
        fechaFin: { lte: addMonths(new Date(), 1), gte: new Date() },
      },
    },
    include: { contract: true },
  });

  if (fianzasVencer.length > 0) {
    alerts.push(await createAlert({
      companyId: params.companyId,
      tipo: 'fianza',
      nivel: 'medio',
      titulo: `${fianzasVencer.length} fianzas con contratos próximos a vencer`,
      descripcion: `Hay ${fianzasVencer.length} fianzas que requieren gestión de devolución en los próximos 30 días.`,
    }));
  }

  return alerts;
}

async function createAlert(data: {
  companyId: string;
  tipo: string;
  nivel: string;
  titulo: string;
  descripcion: string;
}) {
  return await prisma.financialAlert.create({
    data: {
      ...data,
      fechaDeteccion: new Date(),
      resuelta: false,
    },
  });
}

// ============ RECONCILIACIÓN BANCARIA AUTOMÁTICA ============

export interface BankReconciliationParams {
  companyId: string;
  periodo: string; // '2024-01'
  extractoBancario: Array<{
    fecha: Date;
    concepto: string;
    monto: number;
    tipo: 'ingreso' | 'gasto';
  }>;
}

export async function reconcileBankStatement(params: BankReconciliationParams) {
  const [year, month] = params.periodo.split('-');
  const inicio = new Date(parseInt(year), parseInt(month) - 1, 1);
  const fin = endOfMonth(inicio);

  // Obtener pagos registrados en el período
  const pagosRegistrados = await prisma.payment.findMany({
    where: {
      contract: { building: { companyId: params.companyId } },
      estado: 'pagado',
      fechaPago: { gte: inicio, lte: fin },
    },
  });

  // Obtener gastos registrados en el período
  const gastosRegistrados = await prisma.expense.findMany({
    where: {
      building: { companyId: params.companyId },
      fecha: { gte: inicio, lte: fin },
    },
  });

  const conciliados = [];
  const descuadres = [];

  // Intentar conciliar cada línea del extracto
  for (const linea of params.extractoBancario) {
    if (linea.tipo === 'ingreso') {
      const pagoCoincidente = pagosRegistrados.find(
        p => Math.abs(p.monto - linea.monto) < 0.01 && 
             p.fechaPago && 
             Math.abs(p.fechaPago.getTime() - linea.fecha.getTime()) < 86400000 * 3 // 3 días de margen
      );

      if (pagoCoincidente) {
        conciliados.push({ tipo: 'pago', id: pagoCoincidente.id, linea });
      } else {
        descuadres.push({ tipo: 'ingreso_no_registrado', linea });
      }
    } else {
      const gastoCoincidente = gastosRegistrados.find(
        g => Math.abs(g.monto - linea.monto) < 0.01 &&
             Math.abs(g.fecha.getTime() - linea.fecha.getTime()) < 86400000 * 3
      );

      if (gastoCoincidente) {
        conciliados.push({ tipo: 'gasto', id: gastoCoincidente.id, linea });
      } else {
        descuadres.push({ tipo: 'gasto_no_registrado', linea });
      }
    }
  }

  return {
    periodo: params.periodo,
    totalLineas: params.extractoBancario.length,
    conciliados: conciliados.length,
    descuadres: descuadres.length,
    detalleDescuadres: descuadres,
  };
}
