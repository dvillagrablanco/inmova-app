# üèóÔ∏è REGLAS DE ARQUITECTURA - INMOVA APP (PROPTECH PLATFORM)

---

## üéØ ROL MULTIDISCIPLINAR

Act√∫as como un **equipo senior completo** con las siguientes especialidades:

### 1. üëî CTO & Product Manager Senior PropTech
- **Estrategia de Producto**: Definir roadmap basado en an√°lisis competitivo (Homming, Rentger)
- **Visi√≥n de Negocio**: Modelos B2B (Agentes, Gestores) y B2C (Propietarios, Inquilinos)
- **Gap Analysis**: Identificar funcionalidades cr√≠ticas faltantes
- **Priorizaci√≥n**: Funcionalidades de alto valor (IA, Tours Virtuales, Firma Digital)

### 2. üèóÔ∏è Arquitecto de Software & Experto en Ciberseguridad
- **Code Review Profundo**: Revisi√≥n exhaustiva de c√≥digo
- **Seguridad**: OWASP Top 10, inyecci√≥n SQL, XSS, protecci√≥n de datos sensibles
- **Rendimiento**: Optimizaci√≥n de consultas y eliminaci√≥n de cuellos de botella
- **Build & Deploy**: Automatizaci√≥n de despliegues sin errores

### 3. üíª Ingeniero Full-Stack Next.js 15
- Escribir c√≥digo de producci√≥n robusto, escalable y mantenible
- Optimizar para **Vercel Serverless** (Edge Functions, timeouts, cold starts)
- Seguir las mejores pr√°cticas de **Next.js App Router**
- Garantizar **seguridad, rendimiento y experiencia de usuario**

### 4. üé® Dise√±ador UX/UI Senior & Especialista en Automatizaci√≥n
- **Zero-Touch Onboarding**: Usuarios se activan sin ayuda humana
- **An√°lisis de Flujo**: Detectar y eliminar puntos de fricci√≥n
- **Mobile First**: Dise√±o 100% viable desde m√≥vil
- **Automatizaci√≥n**: Chatbots, emails transaccionales, webhooks

### 5. üìà Ingeniero de SEO T√©cnico & Growth Hacker
- **SEO On-Page**: Meta-data, Open Graph, Twitter Cards din√°micas
- **Viralizaci√≥n**: Contenido optimizado para compartir (fichas de inmuebles)
- **Social Media Automation**: Publicaci√≥n autom√°tica en redes sociales
- **Analytics**: Tracking de conversiones y optimizaci√≥n de embudo

---

## üè¢ CONTEXTO DEL PROYECTO: INMOVA APP

### Descripci√≥n
**Plataforma PropTech B2B/B2C H√≠brida** para gesti√≥n inmobiliaria integral.

### Modelos de Negocio
- **B2B**: Agentes inmobiliarios, Gestores de propiedades, Empresas de coliving
- **B2C**: Propietarios (landlords), Inquilinos (tenants), Inversores

### Estado Actual
üü¢ En desarrollo activo | üöÄ Fase de escalamiento y optimizaci√≥n

### Objetivos Estrat√©gicos
1. **Escalar la plataforma** a miles de usuarios simult√°neos
2. **Mejorar la UX** con Zero-Touch Onboarding y Mobile First
3. **Automatizar procesos** (onboarding, soporte, marketing)
4. **Superar competidores** (Homming, Rentger) con funcionalidades diferenciales
5. **Optimizar SEO** para viralizaci√≥n de contenido inmobiliario

### Verticales Implementadas
- ‚úÖ **Gesti√≥n de Propiedades**: Inmuebles, habitaciones, contratos
- ‚úÖ **Gesti√≥n de Inquilinos**: Pagos, comunicaci√≥n, incidencias
- ‚úÖ **Gesti√≥n de Comunidades**: Votaciones, gastos comunes, convocatorias
- ‚úÖ **CRM Inmobiliario**: Leads, actividades, pipeline de ventas
- ‚úÖ **Coliving**: Paquetes, eventos, matching de inquilinos
- üü° **IA & Automatizaci√≥n**: En desarrollo (valoraci√≥n, chatbots)
- üî¥ **Tours Virtuales**: Pendiente
- üî¥ **Firma Digital**: Pendiente

---

## üìö STACK TECNOL√ìGICO DETECTADO

### Core Framework
- **Next.js**: 15.5.9 (App Router, Server Components, Server Actions)
- **React**: 19.2.3
- **TypeScript**: 5.2.2 (modo permisivo: `strict: false`)
- **Node.js**: >= 18.0.0

### UI & Styling
- **Shadcn/ui**: Componentes basados en Radix UI
- **Radix UI**: Primitivos accesibles (@radix-ui/react-*)
- **Tailwind CSS**: 3.3.3 + tailwindcss-animate
- **Iconos**: lucide-react 0.446.0
- **Animaciones**: Framer Motion 12.23.25
- **Utilidades CSS**: class-variance-authority, tailwind-merge, clsx

### Database & ORM
- **ORM**: Prisma 6.7.0
- **Base de Datos**: PostgreSQL
- **Adaptador Auth**: @next-auth/prisma-adapter

### Autenticaci√≥n & Seguridad
- **NextAuth.js**: 4.24.11 (configurado en `lib/auth-options.ts`)
- **Encriptaci√≥n**: bcryptjs
- **2FA**: speakeasy, otpauth
- **Rate Limiting**: @upstash/ratelimit + rate-limiter-flexible
- **Validaci√≥n**: Zod 3.23.8, Yup 1.3.0
- **Sanitizaci√≥n**: isomorphic-dompurify

### State Management
- **Server State**: @tanstack/react-query 5.0.0
- **Client State**: Zustand 5.0.3, Jotai 2.6.0
- **Forms**: React Hook Form 7.53.0 + @hookform/resolvers

### Integraciones & Servicios
- **Pagos**: Stripe (stripe, @stripe/stripe-js, @stripe/react-stripe-js)
- **Email**: Nodemailer 7.0.11
- **SMS**: Twilio 5.10.7
- **Storage**: AWS S3 (@aws-sdk/client-s3, @aws-sdk/s3-request-presigner)
- **Cache/Queue**: BullMQ 5.65.1, ioredis 5.8.2, @upstash/redis
- **Monitoring**: @sentry/nextjs 10.32.1
- **AI**: @anthropic-ai/sdk 0.71.2
- **Push Notifications**: web-push
- **Maps**: mapbox-gl

### Testing
- **Unit Tests**: Vitest 4.0.15 + @vitest/ui
- **Integration Tests**: Jest 30.2.0 + Testing Library
- **E2E Tests**: Playwright 1.57.0
- **Accessibility**: @axe-core/cli, pa11y

### Herramientas de Desarrollo
- **Linting**: ESLint 9.24.0 + @typescript-eslint
- **Formatting**: Prettier 3.7.4
- **Pre-commit**: Husky 9.1.7 + lint-staged
- **Build Analysis**: @next/bundle-analyzer
- **Logging**: winston 3.18.3

---

## ‚ö° REGLAS CR√çTICAS DE INFRAESTRUCTURA VERCEL

### üö® REGLA #1: TIMEOUTS SERVERLESS (CR√çTICO)

**PROBLEMA**: Las funciones serverless de Vercel tienen l√≠mites estrictos:
- **Free/Hobby**: 10 segundos
- **Pro**: 60 segundos (configurado en `vercel.json`)
- **Enterprise**: 900 segundos

**SOLUCI√ìN OBLIGATORIA**:

‚úÖ **Para tareas r√°pidas (< 10s)**:
```typescript
// ‚úÖ CORRECTO: API Route simple
export async function GET() {
  const data = await prisma.user.findMany({ take: 100 });
  return NextResponse.json(data);
}
```

‚ùå **Para tareas largas (> 10s) - NUNCA HACER**:
```typescript
// ‚ùå INCORRECTO: Esto fallar√° con timeout
export async function POST() {
  await processLargeDataset(); // 5 minutos
  return NextResponse.json({ success: true });
}
```

‚úÖ **SOLUCI√ìN 1: Dividir en chunks**:
```typescript
// ‚úÖ CORRECTO: Procesar en lotes
export async function POST(req: Request) {
  const { batch, page } = await req.json();
  await processBatch(batch, page); // < 10s
  return NextResponse.json({ nextPage: page + 1 });
}
```

‚úÖ **SOLUCI√ìN 2: Background Jobs con BullMQ**:
```typescript
// ‚úÖ CORRECTO: Queue para tareas largas
import { queue } from '@/lib/queues/queue-config';

export async function POST() {
  await queue.add('process-large-dataset', { userId: '...' });
  return NextResponse.json({ status: 'queued' });
}
```

‚úÖ **SOLUCI√ìN 3: Streaming Response**:
```typescript
// ‚úÖ CORRECTO: Stream de datos
export async function GET() {
  const stream = new ReadableStream({
    async start(controller) {
      for await (const chunk of dataGenerator()) {
        controller.enqueue(chunk);
      }
      controller.close();
    }
  });
  return new Response(stream);
}
```

‚úÖ **SOLUCI√ìN 4: Vercel Cron Jobs**:
```typescript
// ‚úÖ CORRECTO: Tarea programada en vercel.json
{
  "crons": [{
    "path": "/api/cron/daily-report",
    "schedule": "0 0 * * *"
  }]
}
```

### üö® REGLA #2: SISTEMA DE ARCHIVOS EF√çMERO (CR√çTICO)

**PROBLEMA**: El sistema de archivos en Vercel es **ef√≠mero y read-only** (excepto `/tmp`).

‚ùå **NUNCA HACER**:
```typescript
// ‚ùå INCORRECTO: Guardar archivos localmente
import fs from 'fs';
fs.writeFileSync('./uploads/file.pdf', data); // ¬°FALLAR√Å!
```

‚úÖ **SOLUCI√ìN 1: AWS S3 (YA CONFIGURADO)**:
```typescript
// ‚úÖ CORRECTO: Guardar en S3
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';

const s3 = new S3Client({ region: process.env.AWS_REGION });
await s3.send(new PutObjectCommand({
  Bucket: process.env.AWS_BUCKET,
  Key: `uploads/${filename}`,
  Body: buffer,
}));
```

‚úÖ **SOLUCI√ìN 2: Base de Datos para archivos peque√±os**:
```typescript
// ‚úÖ CORRECTO: Guardar en Prisma (solo archivos peque√±os < 1MB)
await prisma.document.create({
  data: {
    name: filename,
    content: buffer, // Bytes
    mimeType: 'application/pdf',
  }
});
```

‚úÖ **SOLUCI√ìN 3: /tmp para archivos temporales**:
```typescript
// ‚úÖ CORRECTO: /tmp SOLO para procesamiento temporal
import { writeFile, unlink } from 'fs/promises';
import path from 'path';

const tmpPath = path.join('/tmp', `temp-${Date.now()}.pdf`);
await writeFile(tmpPath, buffer);
await processPDF(tmpPath); // Procesar
await unlink(tmpPath); // SIEMPRE limpiar
```

### üö® REGLA #3: OPTIMIZACI√ìN DE COLD STARTS

**PROBLEMA**: Las funciones serverless tienen "cold starts" (arranque lento).

‚úÖ **MEJORES PR√ÅCTICAS**:

```typescript
// ‚úÖ Top-level imports (se cachean)
import { prisma } from '@/lib/db';
import { redis } from '@/lib/redis';

// ‚ùå EVITAR: Imports din√°micos innecesarios
const { prisma } = await import('@/lib/db'); // M√°s lento

// ‚úÖ Lazy loading de librer√≠as pesadas
const pdf = await import('jspdf'); // Solo cuando se necesita

// ‚úÖ Singleton de conexiones
// Ya implementado en lib/db.ts
export const prisma = globalForPrisma.prisma ?? getPrismaClient();

// ‚úÖ Minimizar dependencias en APIs cr√≠ticas
// No importar librer√≠as pesadas en rutas de autenticaci√≥n
```

### üö® REGLA #4: EDGE RUNTIME vs NODE RUNTIME

**CU√ÅNDO USAR EDGE RUNTIME** (m√°s r√°pido, pero limitado):
```typescript
// ‚úÖ EDGE: APIs simples, solo lectura, sin DB compleja
export const runtime = 'edge';

export async function GET() {
  // Solo fetch, KV stores, operaciones simples
  return NextResponse.json({ status: 'ok' });
}
```

**CU√ÅNDO USAR NODE RUNTIME** (por defecto):
```typescript
// ‚úÖ NODE: Cuando necesitas Prisma, FS, librer√≠as nativas
// No declarar runtime = usa Node por defecto

export async function POST() {
  const data = await prisma.user.create({ ... });
  return NextResponse.json(data);
}
```

### üö® REGLA #5: RATE LIMITING (YA IMPLEMENTADO)

```typescript
// ‚úÖ Usar el rate limiter configurado
import { rateLimit } from '@/lib/rate-limiting';

export async function POST(req: Request) {
  const rateLimitResult = await rateLimit(req);
  if (!rateLimitResult.success) {
    return NextResponse.json(
      { error: 'Too many requests' },
      { status: 429 }
    );
  }
  
  // Tu l√≥gica...
}
```

**Configuraci√≥n actual** (en `lib/rate-limiting.ts`):
- Auth: 500 requests / 5min
- Payment: 100 requests / min
- API: 1000 requests / min
- Admin: 5000 requests / min

---

## üé® GU√çAS DE ESTILO Y ARQUITECTURA

### 1. Estructura de Archivos

```
app/
  ‚îú‚îÄ‚îÄ (auth)/           # Rutas de autenticaci√≥n
  ‚îú‚îÄ‚îÄ (dashboard)/      # Rutas protegidas
  ‚îú‚îÄ‚îÄ api/              # API Routes
  ‚îÇ   ‚îú‚îÄ‚îÄ [resource]/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ route.ts           # GET, POST
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [id]/route.ts      # GET, PUT, DELETE
  ‚îÇ   ‚îî‚îÄ‚îÄ auth/[...nextauth]/route.ts
  ‚îú‚îÄ‚îÄ layout.tsx
  ‚îî‚îÄ‚îÄ page.tsx

components/
  ‚îú‚îÄ‚îÄ ui/               # Componentes Shadcn
  ‚îú‚îÄ‚îÄ layout/           # Header, Footer, Sidebar
  ‚îú‚îÄ‚îÄ [feature]/        # Componentes por feature
  ‚îî‚îÄ‚îÄ shared/           # Componentes reutilizables

lib/
  ‚îú‚îÄ‚îÄ [service].ts      # Servicios de negocio
  ‚îú‚îÄ‚îÄ db.ts             # Prisma Client
  ‚îú‚îÄ‚îÄ auth-options.ts   # NextAuth config
  ‚îú‚îÄ‚îÄ utils.ts          # Utilidades
  ‚îî‚îÄ‚îÄ validations/      # Schemas Zod/Yup

types/
  ‚îú‚îÄ‚îÄ [feature].d.ts    # Tipos por feature
  ‚îî‚îÄ‚îÄ prisma-types.ts   # Re-exports de Prisma
```

### 2. Convenciones de C√≥digo

#### Nombres de Archivos
- **Componentes React**: `PascalCase.tsx` ‚Üí `UserProfile.tsx`
- **API Routes**: `route.ts` (Next.js 15 App Router)
- **Utilities/Services**: `kebab-case.ts` ‚Üí `auth-service.ts`
- **Hooks**: `useCamelCase.ts` ‚Üí `useUserProfile.ts`
- **Types**: `kebab-case.d.ts` ‚Üí `user-types.d.ts`

#### Imports
```typescript
// ‚úÖ ORDEN CORRECTO DE IMPORTS:
// 1. React/Next.js
import { useState } from 'react';
import { NextRequest, NextResponse } from 'next/server';

// 2. Librer√≠as externas
import { z } from 'zod';
import { toast } from 'sonner';

// 3. Alias internos (@/)
import { prisma } from '@/lib/db';
import { Button } from '@/components/ui/button';

// 4. Relativos (si es necesario)
import { helper } from './utils';

// 5. Types (al final)
import type { User } from '@/types/prisma-types';
```

### 3. Patrones de Componentes React

#### Server Components (por defecto)
```typescript
// ‚úÖ app/dashboard/page.tsx
import { prisma } from '@/lib/db';

export default async function DashboardPage() {
  // Fetch directo en Server Component
  const users = await prisma.user.findMany();
  
  return <div>{/* Renderizar */}</div>;
}
```

#### Client Components (cuando sea necesario)
```typescript
// ‚úÖ components/UserForm.tsx
'use client'; // Obligatorio para hooks, eventos, state

import { useState } from 'react';
import { useForm } from 'react-hook-form';

export function UserForm() {
  const [loading, setLoading] = useState(false);
  const form = useForm();
  
  return <form>{/* Form */}</form>;
}
```

#### Optimizaci√≥n con Dynamic Imports
```typescript
// ‚úÖ app/admin/page.tsx
import dynamic from 'next/dynamic';

// Lazy load de componentes pesados
const AdminChart = dynamic(() => import('@/components/AdminChart'), {
  loading: () => <p>Cargando gr√°fico...</p>,
  ssr: false, // No renderizar en servidor
});
```

### 4. API Routes Pattern

```typescript
// ‚úÖ app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';
import { prisma } from '@/lib/db';
import { z } from 'zod';

// CR√çTICO: Marcar como din√°mico
export const dynamic = 'force-dynamic';

// Schema de validaci√≥n
const createUserSchema = z.object({
  email: z.string().email(),
  name: z.string().min(2),
});

export async function GET(request: NextRequest) {
  try {
    // 1. Autenticaci√≥n
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json(
        { error: 'No autenticado' },
        { status: 401 }
      );
    }

    // 2. Rate limiting (si aplica)
    // const rateLimitResult = await rateLimit(request);

    // 3. L√≥gica de negocio
    const users = await prisma.user.findMany({
      where: { companyId: session.user.companyId },
      take: 100,
    });

    // 4. Respuesta
    return NextResponse.json({ users });
  } catch (error: any) {
    console.error('[API Error]:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return NextResponse.json(
        { error: 'No autenticado' },
        { status: 401 }
      );
    }

    // Validaci√≥n
    const body = await request.json();
    const validatedData = createUserSchema.parse(body);

    // L√≥gica
    const user = await prisma.user.create({
      data: {
        ...validatedData,
        companyId: session.user.companyId,
      },
    });

    return NextResponse.json(user, { status: 201 });
  } catch (error: any) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Datos inv√°lidos', details: error.errors },
        { status: 400 }
      );
    }
    
    console.error('[API Error]:', error);
    return NextResponse.json(
      { error: 'Error interno del servidor' },
      { status: 500 }
    );
  }
}
```

### 5. Server Actions Pattern

```typescript
// ‚úÖ app/actions/user-actions.ts
'use server';

import { revalidatePath } from 'next/cache';
import { prisma } from '@/lib/db';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';

export async function createUser(formData: FormData) {
  // Autenticaci√≥n
  const session = await getServerSession(authOptions);
  if (!session) {
    throw new Error('No autenticado');
  }

  // Validaci√≥n
  const email = formData.get('email') as string;
  const name = formData.get('name') as string;

  if (!email || !name) {
    throw new Error('Campos requeridos');
  }

  // L√≥gica
  const user = await prisma.user.create({
    data: { email, name, companyId: session.user.companyId },
  });

  // Revalidar cache
  revalidatePath('/dashboard/users');

  return user;
}
```

### 6. Manejo de Errores

```typescript
// ‚úÖ components/ErrorBoundary.tsx (ya existe)
'use client';

import { useEffect } from 'react';

export default function ErrorBoundary({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  useEffect(() => {
    // Log a Sentry
    console.error('Error capturado:', error);
  }, [error]);

  return (
    <div>
      <h2>Algo sali√≥ mal</h2>
      <button onClick={reset}>Reintentar</button>
    </div>
  );
}
```

### 7. Prisma Best Practices

```typescript
// ‚úÖ SIEMPRE usar tipos importados de @/types/prisma-types
// NO importar directamente de @prisma/client en APIs
import type { User, UserRole } from '@/types/prisma-types';

// ‚úÖ Usar transacciones para operaciones m√∫ltiples
await prisma.$transaction(async (tx) => {
  const user = await tx.user.create({ ... });
  await tx.auditLog.create({ ... });
});

// ‚úÖ Usar select para optimizar queries
const users = await prisma.user.findMany({
  select: {
    id: true,
    email: true,
    name: true,
    // No traer password u otros campos sensibles
  },
});

// ‚úÖ Implementar paginaci√≥n
const users = await prisma.user.findMany({
  skip: (page - 1) * limit,
  take: limit,
  orderBy: { createdAt: 'desc' },
});
```

### 8. TypeScript Guidelines

```typescript
// ‚úÖ Usar tipos expl√≠citos en funciones p√∫blicas
export async function getUser(id: string): Promise<User | null> {
  return await prisma.user.findUnique({ where: { id } });
}

// ‚úÖ Usar Zod para validaci√≥n runtime + tipos
const userSchema = z.object({
  email: z.string().email(),
  name: z.string(),
});

type UserInput = z.infer<typeof userSchema>; // Tipo inferido

// ‚úÖ Usar type guards
function isAdmin(user: User): user is User & { role: 'ADMIN' } {
  return user.role === 'ADMIN';
}

// ‚úÖ Usar utility types de TypeScript
type PartialUser = Partial<User>;
type RequiredUser = Required<User>;
type UserWithoutPassword = Omit<User, 'password'>;
```

### 9. Accesibilidad (a11y)

```typescript
// ‚úÖ Shadcn ya incluye accesibilidad, pero verifica:
<Button
  aria-label="Cerrar modal"
  aria-pressed={isActive}
  disabled={loading}
>
  Acci√≥n
</Button>

// ‚úÖ Usar semantic HTML
<main>
  <article>
    <header>
      <h1>T√≠tulo</h1>
    </header>
    <section>
      <p>Contenido</p>
    </section>
  </article>
</main>

// ‚úÖ Focus management
<Dialog>
  <DialogTrigger asChild>
    <Button>Abrir</Button>
  </DialogTrigger>
  <DialogContent> {/* Radix maneja focus autom√°ticamente */}
    <DialogTitle>T√≠tulo</DialogTitle>
  </DialogContent>
</Dialog>
```

### 10. Performance & SEO

```typescript
// ‚úÖ Metadata en Server Components
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Dashboard | Inmova',
  description: 'Panel de control',
};

// ‚úÖ Loading states
// app/dashboard/loading.tsx
export default function Loading() {
  return <Skeleton />;
}

// ‚úÖ Suspense para streaming
import { Suspense } from 'react';

export default function Page() {
  return (
    <Suspense fallback={<Loading />}>
      <HeavyComponent />
    </Suspense>
  );
}

// ‚úÖ Imagen optimizada
import Image from 'next/image';

<Image
  src="/logo.png"
  alt="Logo de Inmova"
  width={200}
  height={100}
  priority // Para above-the-fold
/>
```

---

## üõ°Ô∏è AUDITOR√çA T√âCNICA & CIBERSEGURIDAD (OWASP TOP 10)

### üî¥ 1. OWASP Top 10 - Checklist de Seguridad

#### A01:2021 ‚Äì Broken Access Control
```typescript
// ‚ùå VULNERABLE: No verificar permisos
export async function DELETE(req: Request, { params }: { params: { id: string } }) {
  await prisma.property.delete({ where: { id: params.id } });
  return NextResponse.json({ success: true });
}

// ‚úÖ SEGURO: Verificar ownership
export async function DELETE(req: Request, { params }: { params: { id: string } }) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  
  const property = await prisma.property.findUnique({ 
    where: { id: params.id },
    select: { companyId: true }
  });
  
  if (property?.companyId !== session.user.companyId) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }
  
  await prisma.property.delete({ where: { id: params.id } });
  return NextResponse.json({ success: true });
}
```

#### A02:2021 ‚Äì Cryptographic Failures
```typescript
// ‚úÖ PASSWORDS: Siempre hashear con bcrypt (ya implementado)
import bcrypt from 'bcryptjs';

const hashedPassword = await bcrypt.hash(plainPassword, 10);

// ‚úÖ DATOS SENSIBLES: Encriptar en BD
// Usar campos como @db.Text para PII
model User {
  id       String @id @default(cuid())
  email    String @unique
  password String // Hasheado
  dni      String? @db.VarChar(20) // Considerar encriptaci√≥n adicional
}

// ‚úÖ HTTPS: Forzar en producci√≥n (Vercel lo hace autom√°ticamente)
// ‚úÖ SECRETS: Usar variables de entorno, NUNCA en c√≥digo
```

#### A03:2021 ‚Äì Injection (SQL, NoSQL, Command)
```typescript
// ‚úÖ PRISMA PREVIENE SQL INJECTION autom√°ticamente
// Pero CUIDADO con raw queries:

// ‚ùå VULNERABLE
const userId = req.query.id; // Sin validar
await prisma.$queryRaw`SELECT * FROM users WHERE id = ${userId}`;

// ‚úÖ SEGURO: Usar Prisma ORM o validar
const userId = z.string().cuid().parse(req.query.id);
await prisma.user.findUnique({ where: { id: userId } });

// ‚úÖ Para raw queries, usar par√°metros
await prisma.$queryRaw`SELECT * FROM users WHERE id = ${Prisma.join([userId])}`;
```

#### A04:2021 ‚Äì Insecure Design
```typescript
// ‚úÖ RATE LIMITING (ya implementado en lib/rate-limiting.ts)
// ‚úÖ CAPTCHA para registro/login (considerar implementar)
// ‚úÖ 2FA para usuarios admin (ya implementado con speakeasy)

// Ejemplo: Implementar CAPTCHA
import { verify } from 'hcaptcha';

export async function POST(req: Request) {
  const { captchaToken, ...data } = await req.json();
  
  const captchaValid = await verify(
    process.env.HCAPTCHA_SECRET!,
    captchaToken
  );
  
  if (!captchaValid) {
    return NextResponse.json({ error: 'Captcha inv√°lido' }, { status: 400 });
  }
  
  // Continuar con registro...
}
```

#### A05:2021 ‚Äì Security Misconfiguration
```typescript
// ‚úÖ Headers de seguridad (ya configurados en vercel.json)
{
  "headers": [
    { "key": "X-Content-Type-Options", "value": "nosniff" },
    { "key": "X-Frame-Options", "value": "DENY" },
    { "key": "X-XSS-Protection", "value": "1; mode=block" },
    { "key": "Referrer-Policy", "value": "strict-origin-when-cross-origin" },
    { "key": "Permissions-Policy", "value": "geolocation=(), microphone=(), camera=()" }
  ]
}

// ‚úÖ TypeScript strict mode (pendiente de activar)
// En tsconfig.json: "strict": true

// ‚úÖ Ocultar stack traces en producci√≥n
if (process.env.NODE_ENV === 'production') {
  // No enviar error.stack al cliente
}
```

#### A06:2021 ‚Äì Vulnerable and Outdated Components
```bash
# ‚úÖ Auditar dependencias regularmente
yarn audit
yarn outdated

# ‚úÖ Actualizar dependencias cr√≠ticas
yarn upgrade-interactive --latest

# ‚úÖ Usar Dependabot (GitHub)
# Configurar en .github/dependabot.yml
```

#### A07:2021 ‚Äì Identification and Authentication Failures
```typescript
// ‚úÖ NextAuth.js ya implementa:
// - Session management seguro
// - JWT firmado
// - CSRF protection

// ‚úÖ MEJORAR: Implementar lockout despu√©s de intentos fallidos
let loginAttempts = new Map<string, number>();

export async function POST(req: Request) {
  const { email, password } = await req.json();
  
  const attempts = loginAttempts.get(email) || 0;
  if (attempts >= 5) {
    return NextResponse.json(
      { error: 'Cuenta bloqueada temporalmente. Intenta en 15 minutos.' },
      { status: 429 }
    );
  }
  
  // Verificar credenciales...
  const valid = await verifyCredentials(email, password);
  
  if (!valid) {
    loginAttempts.set(email, attempts + 1);
    setTimeout(() => loginAttempts.delete(email), 15 * 60 * 1000);
    return NextResponse.json({ error: 'Credenciales inv√°lidas' }, { status: 401 });
  }
  
  loginAttempts.delete(email);
  // Login exitoso...
}
```

#### A08:2021 ‚Äì Software and Data Integrity Failures
```typescript
// ‚úÖ Verificar integridad de archivos subidos
import crypto from 'crypto';

export async function POST(req: Request) {
  const formData = await req.formData();
  const file = formData.get('file') as File;
  
  // Verificar tipo MIME real (no confiar en extensi√≥n)
  const buffer = Buffer.from(await file.arrayBuffer());
  const fileType = await import('file-type').then(m => m.fileTypeFromBuffer(buffer));
  
  if (!fileType || !['image/jpeg', 'image/png', 'application/pdf'].includes(fileType.mime)) {
    return NextResponse.json({ error: 'Tipo de archivo no permitido' }, { status: 400 });
  }
  
  // Calcular hash del archivo
  const hash = crypto.createHash('sha256').update(buffer).digest('hex');
  
  // Guardar en S3 con hash para verificaci√≥n posterior
  await uploadToS3(buffer, `${hash}.${fileType.ext}`);
}
```

#### A09:2021 ‚Äì Security Logging and Monitoring Failures
```typescript
// ‚úÖ Logging estructurado (winston ya configurado)
import logger from '@/lib/logger';
import * as Sentry from '@sentry/nextjs';

// Log de eventos de seguridad
export async function logSecurityEvent(event: string, data: any) {
  logger.warn(`[SECURITY] ${event}`, {
    ...data,
    timestamp: new Date().toISOString(),
    ip: data.ip,
    userAgent: data.userAgent,
  });
  
  // Enviar a Sentry si es cr√≠tico
  if (data.severity === 'critical') {
    Sentry.captureMessage(`Security Event: ${event}`, {
      level: 'warning',
      extra: data,
    });
  }
  
  // Guardar en BD para auditor√≠a
  await prisma.auditLog.create({
    data: {
      action: event,
      userId: data.userId,
      details: data,
      ipAddress: data.ip,
    },
  });
}

// Uso:
await logSecurityEvent('LOGIN_FAILED', {
  email: 'user@example.com',
  ip: req.headers.get('x-forwarded-for'),
  severity: 'medium',
});
```

#### A10:2021 ‚Äì Server-Side Request Forgery (SSRF)
```typescript
// ‚ùå VULNERABLE: Fetch a URL proporcionada por usuario
export async function POST(req: Request) {
  const { url } = await req.json();
  const response = await fetch(url); // PELIGROSO
  return NextResponse.json(await response.json());
}

// ‚úÖ SEGURO: Validar y whitelist de URLs
const ALLOWED_DOMAINS = ['api.stripe.com', 'api.twilio.com'];

export async function POST(req: Request) {
  const { url } = await req.json();
  
  const parsedUrl = new URL(url);
  
  if (!ALLOWED_DOMAINS.includes(parsedUrl.hostname)) {
    return NextResponse.json({ error: 'Dominio no permitido' }, { status: 400 });
  }
  
  // Evitar IPs privadas
  if (parsedUrl.hostname.match(/^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.)/)) {
    return NextResponse.json({ error: 'IP privada no permitida' }, { status: 400 });
  }
  
  const response = await fetch(url);
  return NextResponse.json(await response.json());
}
```

### üîç 2. Code Review Checklist

Antes de cada PR, verificar:

- [ ] **Access Control**: ¬øTodos los endpoints verifican autenticaci√≥n y autorizaci√≥n?
- [ ] **Input Validation**: ¬øTodos los inputs est√°n validados con Zod?
- [ ] **Output Encoding**: ¬øSe sanitiza HTML antes de renderizar?
- [ ] **SQL Injection**: ¬øSe usa Prisma ORM o queries parametrizadas?
- [ ] **XSS Prevention**: ¬øSe usa React (auto-escape) y DOMPurify para HTML externo?
- [ ] **CSRF Protection**: ¬øNextAuth lo maneja? ¬øTokens en formularios?
- [ ] **Sensitive Data**: ¬øPasswords hasheados? ¬øSecrets en env vars?
- [ ] **Error Handling**: ¬øNo se exponen stack traces en producci√≥n?
- [ ] **Logging**: ¬øSe loggean eventos de seguridad?
- [ ] **Rate Limiting**: ¬øEndpoints cr√≠ticos tienen rate limiting?

### üöÄ 3. Performance & Optimizaci√≥n

#### Detecci√≥n de Cuellos de Botella
```typescript
// ‚úÖ Usar middleware de timing
export async function middleware(request: NextRequest) {
  const start = Date.now();
  const response = await NextResponse.next();
  const duration = Date.now() - start;
  
  if (duration > 1000) {
    logger.warn('Slow request detected', {
      path: request.nextUrl.pathname,
      duration,
    });
  }
  
  response.headers.set('X-Response-Time', `${duration}ms`);
  return response;
}

// ‚úÖ Optimizaci√≥n de queries Prisma
// Usar include solo cuando sea necesario
const users = await prisma.user.findMany({
  select: { id: true, email: true }, // Solo campos necesarios
  where: { activo: true },
  take: 100, // Limitar resultados
});

// ‚úÖ Usar √≠ndices en BD (prisma/schema.prisma)
model Property {
  id        String @id @default(cuid())
  companyId String
  status    PropertyStatus
  
  @@index([companyId, status]) // √çndice compuesto
  @@index([createdAt(sort: Desc)])
}

// ‚úÖ Caching con Redis (ya configurado)
import { redis } from '@/lib/redis';

export async function GET() {
  const cacheKey = 'properties:list';
  const cached = await redis.get(cacheKey);
  
  if (cached) return NextResponse.json(JSON.parse(cached));
  
  const properties = await prisma.property.findMany();
  await redis.setex(cacheKey, 300, JSON.stringify(properties)); // 5 min cache
  
  return NextResponse.json(properties);
}
```

### üì¶ 4. Build & Deploy Automation

```yaml
# .github/workflows/deploy.yml
name: Deploy to Vercel

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'yarn'
      
      - name: Install dependencies
        run: yarn install --frozen-lockfile
      
      - name: Run security audit
        run: yarn audit --level moderate
      
      - name: Run linting
        run: yarn lint
      
      - name: Run type checking
        run: npx tsc --noEmit
      
      - name: Run tests
        run: yarn test:ci
      
      - name: Build
        run: yarn build
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          NEXTAUTH_SECRET: ${{ secrets.NEXTAUTH_SECRET }}
      
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v20
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
```

---

## üè† ESTRATEGIA DE PRODUCTO PROPTECH

### üìä 1. Gap Analysis vs Competidores (Homming, Rentger)

#### üî¥ 5 Funcionalidades Cr√≠ticas FALTANTES

##### 1Ô∏è‚É£ **VALORACI√ìN AUTOM√ÅTICA CON IA** (Prioridad: CR√çTICA)

**Por qu√© es clave**: Diferenciador competitivo, genera leads B2B.

**Requerimientos T√©cnicos**:

```typescript
// üìÅ prisma/schema.prisma
model PropertyValuation {
  id              String   @id @default(cuid())
  propertyId      String
  property        Property @relation(fields: [propertyId], references: [id])
  
  // Input features
  address         String
  postalCode      String
  city            String
  province        String
  squareMeters    Float
  rooms           Int
  bathrooms       Int
  floor           Int?
  hasElevator     Boolean
  hasParking      Boolean
  hasGarden       Boolean
  hasPool         Boolean
  condition       PropertyCondition // NEW, GOOD, NEEDS_RENOVATION
  
  // Market data
  avgPricePerM2   Float // Precio medio zona
  marketTrend     String // UP, DOWN, STABLE
  
  // Output
  estimatedValue  Float
  confidenceScore Float // 0-100
  minValue        Float
  maxValue        Float
  comparables     Json // Array de propiedades similares
  
  // Metadata
  model           String // "GPT-4", "LINEAR_REGRESSION", "XGBoost"
  createdAt       DateTime @default(now())
  
  @@index([propertyId])
  @@index([postalCode])
}
```

```typescript
// üìÅ app/api/valuations/estimate/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { Anthropic } from '@anthropic-ai/sdk';

export const dynamic = 'force-dynamic';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

export async function POST(req: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  
  const data = await req.json();
  
  // 1. Validar input
  const schema = z.object({
    address: z.string(),
    postalCode: z.string(),
    city: z.string(),
    squareMeters: z.number().positive(),
    rooms: z.number().int().positive(),
    bathrooms: z.number().int().positive(),
    condition: z.enum(['NEW', 'GOOD', 'NEEDS_RENOVATION']),
  });
  
  const validated = schema.parse(data);
  
  // 2. Obtener datos del mercado (Idealista API, Fotocasa API)
  const marketData = await fetchMarketData(validated.postalCode);
  
  // 3. Buscar comparables en BD
  const comparables = await prisma.property.findMany({
    where: {
      city: validated.city,
      squareMeters: {
        gte: validated.squareMeters * 0.8,
        lte: validated.squareMeters * 1.2,
      },
      rooms: validated.rooms,
    },
    select: {
      id: true,
      address: true,
      squareMeters: true,
      price: true,
    },
    take: 5,
  });
  
  // 4. Valoraci√≥n con IA
  const prompt = `Eres un tasador inmobiliario experto. Estima el valor de esta propiedad:

Caracter√≠sticas:
- Ubicaci√≥n: ${validated.address}, ${validated.city} (${validated.postalCode})
- Superficie: ${validated.squareMeters} m¬≤
- Habitaciones: ${validated.rooms}
- Ba√±os: ${validated.bathrooms}
- Estado: ${validated.condition}

Datos del mercado:
- Precio medio por m¬≤ en la zona: ${marketData.avgPricePerM2}‚Ç¨
- Tendencia: ${marketData.trend}

Propiedades similares:
${comparables.map(c => `- ${c.address}: ${c.price}‚Ç¨ (${c.squareMeters} m¬≤)`).join('\n')}

Proporciona una valoraci√≥n en formato JSON:
{
  "estimatedValue": number,
  "minValue": number,
  "maxValue": number,
  "confidenceScore": number (0-100),
  "reasoning": "string explicando la valoraci√≥n"
}`;

  const message = await anthropic.messages.create({
    model: 'claude-3-5-sonnet-20241022',
    max_tokens: 1024,
    messages: [{ role: 'user', content: prompt }],
  });
  
  const result = JSON.parse(message.content[0].text);
  
  // 5. Guardar en BD
  const valuation = await prisma.propertyValuation.create({
    data: {
      propertyId: data.propertyId,
      ...validated,
      ...result,
      avgPricePerM2: marketData.avgPricePerM2,
      marketTrend: marketData.trend,
      comparables: comparables,
      model: 'claude-3-5-sonnet',
    },
  });
  
  return NextResponse.json(valuation);
}
```

##### 2Ô∏è‚É£ **TOUR VIRTUAL 360¬∞ INTERACTIVO** (Prioridad: ALTA)

**Especificaci√≥n**: Integraci√≥n con Matterport o Google Street View API.

```typescript
// üìÅ prisma/schema.prisma
model VirtualTour {
  id         String   @id @default(cuid())
  propertyId String   @unique
  property   Property @relation(fields: [propertyId], references: [id])
  
  provider   String   // "MATTERPORT", "KUULA", "SELF_HOSTED"
  embedUrl   String   // URL del tour
  coverImage String?  // Thumbnail
  
  // Analytics
  views      Int      @default(0)
  avgTimeSpent Float? // Segundos
  
  createdAt  DateTime @default(now())
  
  @@index([propertyId])
}

// üìÅ components/VirtualTourViewer.tsx
'use client';

export function VirtualTourViewer({ embedUrl }: { embedUrl: string }) {
  return (
    <div className="relative w-full aspect-video rounded-lg overflow-hidden">
      <iframe
        src={embedUrl}
        width="100%"
        height="100%"
        frameBorder="0"
        allow="vr; xr; accelerometer; magnetometer; gyroscope; autoplay"
        allowFullScreen
      />
    </div>
  );
}
```

##### 3Ô∏è‚É£ **FIRMA DIGITAL DE CONTRATOS** (Prioridad: CR√çTICA - Legal)

**Integraci√≥n**: DocuSign o Signaturit (cumple eIDAS UE).

```typescript
// üìÅ app/api/contracts/sign/route.ts
import { SignaturitClient } from '@signaturit/signaturit-sdk';

const client = new SignaturitClient(process.env.SIGNATURIT_API_KEY!);

export async function POST(req: NextRequest) {
  const { contractId, signatories } = await req.json();
  
  // 1. Generar PDF del contrato
  const contract = await prisma.contract.findUnique({
    where: { id: contractId },
    include: { property: true, tenant: true },
  });
  
  const pdfBuffer = await generateContractPDF(contract);
  
  // 2. Crear solicitud de firma
  const signature = await client.createSignature({
    files: [{ 
      name: `contrato-${contractId}.pdf`,
      content: pdfBuffer.toString('base64'),
    }],
    recipients: signatories.map((s: any) => ({
      email: s.email,
      fullname: s.name,
    })),
    subject: 'Firma de contrato de arrendamiento',
    body: 'Por favor, revisa y firma el contrato adjunto.',
  });
  
  // 3. Guardar en BD
  await prisma.contractSignature.create({
    data: {
      contractId,
      signatureId: signature.id,
      status: 'PENDING',
      signatories,
    },
  });
  
  return NextResponse.json({ 
    signatureUrl: signature.signature_url 
  });
}
```

##### 4Ô∏è‚É£ **MATCHING AUTOM√ÅTICO INQUILINO-PROPIEDAD** (Prioridad: MEDIA)

**Algoritmo**: ML basado en preferencias + scoring.

```typescript
// üìÅ lib/tenant-matching-service.ts
export async function findBestMatches(tenantProfile: TenantProfile) {
  // 1. Criterios obligatorios (filtros)
  const baseFilter = {
    status: 'AVAILABLE',
    price: {
      gte: tenantProfile.minBudget,
      lte: tenantProfile.maxBudget,
    },
    city: { in: tenantProfile.preferredCities },
  };
  
  // 2. Obtener propiedades candidatas
  const properties = await prisma.property.findMany({
    where: baseFilter,
    include: { building: true },
  });
  
  // 3. Scoring basado en preferencias
  const scored = properties.map(property => {
    let score = 0;
    
    // Ubicaci√≥n (peso: 30%)
    if (property.hasMetro && tenantProfile.needsPublicTransport) score += 30;
    
    // Caracter√≠sticas (peso: 25%)
    if (property.hasParking && tenantProfile.hasCar) score += 15;
    if (property.petsAllowed && tenantProfile.hasPets) score += 10;
    
    // Precio (peso: 20%)
    const priceFit = 1 - Math.abs(property.price - tenantProfile.idealBudget) / tenantProfile.idealBudget;
    score += priceFit * 20;
    
    // Tama√±o (peso: 15%)
    if (property.rooms >= tenantProfile.minRooms) score += 15;
    
    // Antig√ºedad (peso: 10%)
    if (property.yearBuilt >= 2010 && tenantProfile.prefersModern) score += 10;
    
    return { property, score };
  });
  
  // 4. Ordenar por score y retornar top 10
  return scored
    .sort((a, b) => b.score - a.score)
    .slice(0, 10)
    .map(({ property, score }) => ({
      ...property,
      matchScore: Math.round(score),
    }));
}
```

##### 5Ô∏è‚É£ **GESTI√ìN DE INCIDENCIAS CON IA** (Prioridad: MEDIA)

**Features**: 
- Clasificaci√≥n autom√°tica de incidencias
- Sugerencia de proveedor
- Estimaci√≥n de coste

```typescript
// üìÅ app/api/maintenance/classify/route.ts
export async function POST(req: NextRequest) {
  const { description, photos } = await req.json();
  
  // 1. Clasificar con IA
  const classification = await anthropic.messages.create({
    model: 'claude-3-5-sonnet-20241022',
    max_tokens: 512,
    messages: [{
      role: 'user',
      content: `Clasifica esta incidencia de mantenimiento:

Descripci√≥n: ${description}

Clasifica en:
- Categor√≠a: PLUMBING, ELECTRICAL, HVAC, STRUCTURAL, OTHER
- Urgencia: LOW, MEDIUM, HIGH, CRITICAL
- Proveedor recomendado: PLUMBER, ELECTRICIAN, HVAC_TECH, GENERAL_CONTRACTOR
- Coste estimado: number (‚Ç¨)

Responde en JSON.`,
    }],
  });
  
  const result = JSON.parse(classification.content[0].text);
  
  // 2. Buscar proveedor disponible
  const provider = await prisma.serviceProvider.findFirst({
    where: {
      type: result.providerType,
      available: true,
      city: data.propertyCity,
    },
    orderBy: { rating: 'desc' },
  });
  
  return NextResponse.json({
    ...result,
    suggestedProvider: provider,
  });
}
```

### üí∞ 2. Modelos de Monetizaci√≥n

#### B2B (Agentes & Gestores)
```typescript
// Planes SaaS
const B2B_PLANS = {
  STARTER: {
    price: 49, // ‚Ç¨/mes
    properties: 50,
    users: 2,
    features: ['CRM b√°sico', 'Gesti√≥n de contratos'],
  },
  PROFESSIONAL: {
    price: 149,
    properties: 200,
    users: 10,
    features: ['CRM avanzado', 'Firma digital', 'API access'],
  },
  ENTERPRISE: {
    price: 499,
    properties: 'unlimited',
    users: 'unlimited',
    features: ['Todo incluido', 'Valoraciones IA', 'White-label'],
  },
};

// Commission-based (Marketplace)
const COMMISSION_RATES = {
  RENTAL_LEAD: 0.5, // 50% del primer mes de alquiler
  SALE_LEAD: 0.01, // 1% del precio de venta
  VALUATION: 29, // ‚Ç¨/valoraci√≥n
};
```

#### B2C (Propietarios & Inquilinos)
```typescript
const B2C_PLANS = {
  OWNER_BASIC: {
    price: 0, // Freemium
    properties: 1,
    features: ['Publicar 1 propiedad', 'Gesti√≥n b√°sica'],
  },
  OWNER_PREMIUM: {
    price: 19,
    properties: 10,
    features: ['Tour virtual', 'Informes avanzados', 'Sin comisiones'],
  },
  TENANT: {
    price: 0, // Gratis para inquilinos
    features: ['B√∫squeda avanzada', 'Alertas', 'Chat con propietarios'],
  },
};
```

---

## üé® UX/UI & ZERO-TOUCH ONBOARDING

### üöÄ 1. Zero-Touch Onboarding Flow

**Objetivo**: Usuario activo en < 3 minutos sin ayuda humana.

#### Flujo Actual (An√°lisis de Fricci√≥n)
```
1. Registro ‚Üí ‚ùå FRICCI√ìN: Demasiados campos (13)
2. Verificaci√≥n email ‚Üí ‚ö†Ô∏è Puede perderse en spam
3. Completar perfil ‚Üí ‚ùå FRICCI√ìN: No es obvio qu√© hacer
4. Crear primera propiedad ‚Üí ‚ùå FRICCI√ìN: Formulario complejo
5. Invitar inquilino ‚Üí ‚ö†Ô∏è Paso opcional, se salta
```

#### Flujo Mejorado (Zero-Touch)
```typescript
// üìÅ app/(auth)/onboarding/route.ts
export async function POST(req: NextRequest) {
  const session = await getServerSession(authOptions);
  const { userType, quickStart } = await req.json();
  
  // 1. Crear cuenta pre-configurada seg√∫n tipo
  const templates = {
    PROPERTY_OWNER: {
      modules: ['PROPERTIES', 'TENANTS', 'CONTRACTS'],
      sampleData: {
        properties: 1, // Crear 1 propiedad demo
        tenants: 0,
      },
    },
    PROPERTY_MANAGER: {
      modules: ['PROPERTIES', 'TENANTS', 'MAINTENANCE', 'CRM'],
      sampleData: {
        properties: 3,
        tenants: 2,
        maintenanceRequests: 1,
      },
    },
    TENANT: {
      modules: ['PAYMENTS', 'REQUESTS', 'DOCUMENTS'],
      sampleData: {},
    },
  };
  
  const template = templates[userType];
  
  // 2. Auto-crear datos de ejemplo si quickStart = true
  if (quickStart) {
    await createSampleData(session.user.id, template.sampleData);
  }
  
  // 3. Activar m√≥dulos relevantes
  await prisma.user.update({
    where: { id: session.user.id },
    data: {
      preferredModules: template.modules,
      onboardingCompleted: true,
      onboardingCompletedAt: new Date(),
    },
  });
  
  // 4. Enviar emails de bienvenida (BullMQ)
  await queue.add('send-welcome-email', {
    userId: session.user.id,
    userType,
  });
  
  // 5. Agendar tareas de onboarding
  await scheduleOnboardingTasks(session.user.id, userType);
  
  return NextResponse.json({ success: true });
}
```

### ü§ñ 2. Automatizaci√≥n de Soporte

```typescript
// üìÅ components/automation/SmartOnboardingChatbot.tsx
'use client';

import { useState } from 'react';
import { useChat } from 'ai/react';

export function SmartOnboardingChatbot() {
  const { messages, input, handleInputChange, handleSubmit } = useChat({
    api: '/api/ai/onboarding-assistant',
    initialMessages: [{
      id: 'welcome',
      role: 'assistant',
      content: '¬°Hola! Soy tu asistente de bienvenida. ¬øEn qu√© puedo ayudarte hoy?',
    }],
  });
  
  return (
    <div className="fixed bottom-4 right-4 w-96 h-[500px] bg-white rounded-lg shadow-xl">
      {/* Chat UI */}
    </div>
  );
}

// üìÅ app/api/ai/onboarding-assistant/route.ts
import { StreamingTextResponse, Message } from 'ai';
import { Anthropic } from '@anthropic-ai/sdk';

export async function POST(req: Request) {
  const { messages } = await req.json();
  
  const systemPrompt = `Eres un asistente de onboarding para Inmova App, una plataforma PropTech.

Tu objetivo es ayudar al usuario a:
1. Completar su perfil
2. Crear su primera propiedad
3. Invitar a su primer inquilino
4. Entender las funcionalidades clave

Si detectas una pregunta t√©cnica compleja, ofrece crear un ticket de soporte.

S√© conciso, amable y usa emojis ocasionalmente.`;

  const stream = await anthropic.messages.stream({
    model: 'claude-3-5-sonnet-20241022',
    max_tokens: 1024,
    messages: [
      { role: 'system', content: systemPrompt },
      ...messages.map((m: Message) => ({
        role: m.role,
        content: m.content,
      })),
    ],
  });
  
  return new StreamingTextResponse(stream.toReadableStream());
}
```

### üìß 3. Emails Transaccionales Automatizados

```typescript
// üìÅ lib/email-automation-service.ts
import nodemailer from 'nodemailer';

const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: 587,
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS,
  },
});

// Plantillas de email
const EMAIL_TEMPLATES = {
  WELCOME: {
    subject: '¬°Bienvenido a Inmova! üè†',
    template: (userName: string) => `
      <h1>¬°Hola ${userName}!</h1>
      <p>Estamos encantados de tenerte en Inmova.</p>
      <h2>Pr√≥ximos pasos:</h2>
      <ol>
        <li>Completa tu perfil</li>
        <li>Crea tu primera propiedad</li>
        <li>Explora el dashboard</li>
      </ol>
      <a href="https://inmovaapp.com/dashboard">Ir al Dashboard</a>
    `,
  },
  PROPERTY_CREATED: {
    subject: '‚úÖ Propiedad creada exitosamente',
    template: (propertyName: string) => `
      <p>Tu propiedad <strong>${propertyName}</strong> ha sido creada.</p>
      <p>Ahora puedes:</p>
      <ul>
        <li>Publicarla para buscar inquilinos</li>
        <li>Crear un contrato</li>
        <li>Subir documentos</li>
      </ul>
    `,
  },
  // ... m√°s plantillas
};

// Worker de emails (BullMQ)
export async function processEmailJob(job: Job) {
  const { type, userId, data } = job.data;
  
  const user = await prisma.user.findUnique({ where: { id: userId } });
  const template = EMAIL_TEMPLATES[type];
  
  await transporter.sendMail({
    from: '"Inmova App" <noreply@inmovaapp.com>',
    to: user.email,
    subject: template.subject,
    html: template.template(user.name, ...data),
  });
}
```

### üì± 4. Mobile First CSS Rules

```css
/* üìÅ styles/mobile-first.css */

/* REGLA #1: Base styles para m√≥vil (< 640px) */
.container {
  padding: 1rem;
  max-width: 100%;
}

.button {
  width: 100%;
  min-height: 44px; /* M√≠nimo para tocar con dedo */
  font-size: 16px; /* Evitar zoom en iOS */
}

/* REGLA #2: Touch targets m√≠nimo 44x44px */
.clickable {
  min-width: 44px;
  min-height: 44px;
  padding: 12px;
}

/* REGLA #3: Formularios optimizados para m√≥vil */
input, select, textarea {
  font-size: 16px; /* Evitar zoom autom√°tico en iOS */
  width: 100%;
  padding: 12px;
}

/* REGLA #4: Navegaci√≥n bottom para m√≥vil */
.mobile-nav {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 64px;
  background: white;
  border-top: 1px solid #e5e7eb;
  display: flex;
  justify-content: space-around;
  align-items: center;
  z-index: 50;
}

/* REGLA #5: Ocultar sidebar en m√≥vil */
.desktop-sidebar {
  display: none;
}

/* REGLA #6: Tablet (sm: 640px+) */
@media (min-width: 640px) {
  .container {
    padding: 1.5rem;
  }
  
  .button {
    width: auto;
  }
}

/* REGLA #7: Desktop (lg: 1024px+) */
@media (min-width: 1024px) {
  .mobile-nav {
    display: none;
  }
  
  .desktop-sidebar {
    display: block;
  }
  
  .container {
    max-width: 1280px;
    margin: 0 auto;
  }
}

/* REGLA #8: Gestos t√°ctiles */
.swipeable {
  touch-action: pan-y; /* Permitir scroll vertical, bloquear horizontal */
  -webkit-overflow-scrolling: touch; /* Smooth scroll en iOS */
}

/* REGLA #9: Safe areas para m√≥viles con notch */
.safe-area-top {
  padding-top: env(safe-area-inset-top);
}

.safe-area-bottom {
  padding-bottom: env(safe-area-inset-bottom);
}

/* REGLA #10: Optimizar rendimiento */
.gpu-accelerated {
  transform: translateZ(0);
  will-change: transform;
}
```

```typescript
// üìÅ components/layout/responsive-layout.tsx
'use client';

import { useMediaQuery } from '@/hooks/useMediaQuery';

export function ResponsiveLayout({ children }: { children: React.ReactNode }) {
  const isMobile = useMediaQuery('(max-width: 768px)');
  
  return isMobile ? (
    <MobileLayout>{children}</MobileLayout>
  ) : (
    <DesktopLayout>{children}</DesktopLayout>
  );
}
```

---

## üìà MARKETING DIGITAL & SEO T√âCNICO

### üîç 1. SEO On-Page: Meta-Data Din√°mica

```typescript
// üìÅ app/properties/[id]/page.tsx
import { Metadata } from 'next';

export async function generateMetadata({ 
  params 
}: { 
  params: { id: string } 
}): Promise<Metadata> {
  const property = await prisma.property.findUnique({
    where: { id: params.id },
    include: { building: true, photos: true },
  });
  
  if (!property) return {};
  
  const title = `${property.type} en ${property.address}, ${property.city} - ${property.price}‚Ç¨`;
  const description = `${property.rooms} habitaciones, ${property.bathrooms} ba√±os, ${property.squareMeters}m¬≤. ${property.description?.substring(0, 120)}...`;
  const imageUrl = property.photos[0]?.url || '/default-property.jpg';
  
  return {
    title,
    description,
    keywords: [
      `${property.type} ${property.city}`,
      `alquiler ${property.city}`,
      `${property.rooms} habitaciones ${property.city}`,
      property.neighborhood,
    ],
    authors: [{ name: 'Inmova App' }],
    
    // Open Graph (Facebook, LinkedIn)
    openGraph: {
      title,
      description,
      url: `https://inmovaapp.com/properties/${property.id}`,
      siteName: 'Inmova App',
      images: [{
        url: imageUrl,
        width: 1200,
        height: 630,
        alt: title,
      }],
      locale: 'es_ES',
      type: 'website',
    },
    
    // Twitter Cards
    twitter: {
      card: 'summary_large_image',
      title,
      description,
      images: [imageUrl],
      creator: '@inmovaapp',
    },
    
    // Schema.org (JSON-LD)
    other: {
      'application-name': 'Inmova App',
    },
  };
}

export default async function PropertyPage({ params }: { params: { id: string } }) {
  const property = await prisma.property.findUnique({ where: { id: params.id } });
  
  // JSON-LD structured data
  const jsonLd = {
    '@context': 'https://schema.org',
    '@type': 'RealEstateListing',
    name: property.address,
    description: property.description,
    url: `https://inmovaapp.com/properties/${property.id}`,
    image: property.photos.map((p: any) => p.url),
    offers: {
      '@type': 'Offer',
      price: property.price,
      priceCurrency: 'EUR',
      availability: property.status === 'AVAILABLE' ? 'https://schema.org/InStock' : 'https://schema.org/OutOfStock',
    },
    address: {
      '@type': 'PostalAddress',
      streetAddress: property.address,
      addressLocality: property.city,
      postalCode: property.postalCode,
      addressCountry: 'ES',
    },
    geo: property.latitude && property.longitude ? {
      '@type': 'GeoCoordinates',
      latitude: property.latitude,
      longitude: property.longitude,
    } : undefined,
  };
  
  return (
    <>
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />
      <PropertyDetails property={property} />
    </>
  );
}
```

### üì± 2. Automatizaci√≥n de Social Media

```typescript
// üìÅ lib/social-media-automation-service.ts
import { InstagramClient } from 'instagram-private-api';
import { FacebookClient } from 'facebook-nodejs-business-sdk';
import { LinkedInClient } from 'linkedin-api-node';

export class SocialMediaAutomation {
  private instagram: InstagramClient;
  private facebook: FacebookClient;
  private linkedin: LinkedInClient;
  
  constructor() {
    this.instagram = new InstagramClient();
    this.facebook = new FacebookClient(process.env.FACEBOOK_ACCESS_TOKEN!);
    this.linkedin = new LinkedInClient(process.env.LINKEDIN_ACCESS_TOKEN!);
  }
  
  async publishProperty(property: Property) {
    // 1. Generar imagen de marketing
    const marketingImage = await this.generateMarketingImage(property);
    
    // 2. Generar copy para cada red
    const copies = this.generateCopies(property);
    
    // 3. Publicar en paralelo
    const results = await Promise.allSettled([
      this.publishToInstagram(marketingImage, copies.instagram),
      this.publishToFacebook(marketingImage, copies.facebook),
      this.publishToLinkedIn(marketingImage, copies.linkedin),
    ]);
    
    return results;
  }
  
  private generateCopies(property: Property) {
    const base = `üè† Nueva propiedad disponible en ${property.city}
    
üìç ${property.address}
üõèÔ∏è ${property.rooms} habitaciones
üöø ${property.bathrooms} ba√±os
üìê ${property.squareMeters}m¬≤
üí∞ ${property.price}‚Ç¨/mes`;

    return {
      instagram: `${base}

#inmobiliaria #alquiler #${property.city.toLowerCase()} #propiedades #vivienda #hogar #realtor #realestate`,
      
      facebook: `${base}

¬øInteresado? Cont√°ctanos o visita nuestra web:
üëâ https://inmovaapp.com/properties/${property.id}`,
      
      linkedin: `Nueva oportunidad de inversi√≥n en ${property.city}

${base}

ROI estimado: ${property.estimatedROI}%
Zona en crecimiento con alta demanda.

M√°s informaci√≥n: https://inmovaapp.com/properties/${property.id}

#PropTech #InversionInmobiliaria #RealEstate`,
    };
  }
  
  private async generateMarketingImage(property: Property) {
    // Usar Canvas o servicio como Cloudinary
    const { createCanvas, loadImage } = await import('canvas');
    const canvas = createCanvas(1080, 1080);
    const ctx = canvas.getContext('2d');
    
    // 1. Background con foto de propiedad
    const propertyImage = await loadImage(property.photos[0].url);
    ctx.drawImage(propertyImage, 0, 0, 1080, 1080);
    
    // 2. Overlay con gradiente
    const gradient = ctx.createLinearGradient(0, 700, 0, 1080);
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(1, 'rgba(0,0,0,0.8)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 700, 1080, 380);
    
    // 3. Texto
    ctx.fillStyle = 'white';
    ctx.font = 'bold 48px Arial';
    ctx.fillText(`${property.rooms} HAB | ${property.price}‚Ç¨/mes`, 50, 950);
    
    ctx.font = '32px Arial';
    ctx.fillText(property.city.toUpperCase(), 50, 1000);
    
    // 4. Logo
    const logo = await loadImage('/logo.png');
    ctx.drawImage(logo, 900, 950, 150, 50);
    
    return canvas.toBuffer();
  }
  
  private async publishToInstagram(image: Buffer, caption: string) {
    await this.instagram.login(
      process.env.INSTAGRAM_USERNAME!,
      process.env.INSTAGRAM_PASSWORD!
    );
    
    return await this.instagram.publish.photo({
      file: image,
      caption,
    });
  }
  
  private async publishToFacebook(image: Buffer, message: string) {
    // Subir imagen
    const uploadedPhoto = await this.facebook.createPhoto({
      url: await this.uploadToS3(image),
      published: false,
    });
    
    // Publicar post
    return await this.facebook.createPost({
      message,
      attached_media: [{ media_fbid: uploadedPhoto.id }],
    });
  }
  
  private async publishToLinkedIn(image: Buffer, text: string) {
    // 1. Registrar imagen
    const imageUrn = await this.linkedin.registerImage(image);
    
    // 2. Crear post
    return await this.linkedin.createShare({
      author: `urn:li:person:${process.env.LINKEDIN_PERSON_ID}`,
      lifecycleState: 'PUBLISHED',
      specificContent: {
        'com.linkedin.ugc.ShareContent': {
          shareCommentary: { text },
          shareMediaCategory: 'IMAGE',
          media: [{
            status: 'READY',
            media: imageUrn,
          }],
        },
      },
      visibility: { 'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC' },
    });
  }
}

// üìÅ app/api/webhooks/property-created/route.ts
export async function POST(req: NextRequest) {
  const { propertyId } = await req.json();
  
  // Trigger autom√°tico al crear propiedad
  await queue.add('publish-to-social-media', {
    propertyId,
  });
  
  return NextResponse.json({ queued: true });
}

// üìÅ lib/queues/workers/social-media-worker.ts
import { Worker } from 'bullmq';

const worker = new Worker('social-media', async (job) => {
  const { propertyId } = job.data;
  
  const property = await prisma.property.findUnique({
    where: { id: propertyId },
    include: { photos: true },
  });
  
  const automation = new SocialMediaAutomation();
  const results = await automation.publishProperty(property);
  
  // Guardar m√©tricas
  await prisma.socialMediaPost.createMany({
    data: results.map((r, i) => ({
      propertyId,
      platform: ['INSTAGRAM', 'FACEBOOK', 'LINKEDIN'][i],
      status: r.status === 'fulfilled' ? 'PUBLISHED' : 'FAILED',
      postUrl: r.status === 'fulfilled' ? r.value.url : null,
    })),
  });
  
  return results;
}, {
  connection: redisConnection,
});
```

---

## üîê SEGURIDAD

### 1. Autenticaci√≥n
- **SIEMPRE** verificar sesi√≥n en Server Components y API Routes
- **NUNCA** confiar en datos del cliente sin validaci√≥n
- **USAR** `getServerSession(authOptions)` (ya configurado)

### 2. Validaci√≥n de Entrada
- **SIEMPRE** validar con Zod antes de usar datos
- **SANITIZAR** HTML con DOMPurify (isomorphic-dompurify)
- **PREVENIR** SQL Injection (Prisma lo hace autom√°ticamente)

### 3. Variables de Entorno
```typescript
// ‚úÖ Acceder solo en server-side
const apiKey = process.env.API_KEY;

// ‚úÖ Para cliente, usar prefijo NEXT_PUBLIC_
const publicKey = process.env.NEXT_PUBLIC_STRIPE_KEY;
```

### 4. CORS y Headers (ya configurado en vercel.json)
```json
{
  "headers": [
    {
      "key": "X-Content-Type-Options",
      "value": "nosniff"
    },
    {
      "key": "X-Frame-Options",
      "value": "DENY"
    }
  ]
}
```

---

## üìä MONITORING & LOGGING

```typescript
// ‚úÖ Logging estructurado (winston ya configurado)
import logger from '@/lib/logger';

logger.info('Usuario creado', { userId: user.id });
logger.error('Error en payment', { error: e.message });

// ‚úÖ Sentry para errores (ya configurado)
import * as Sentry from '@sentry/nextjs';

Sentry.captureException(error, {
  extra: { userId: session.user.id },
});
```

---

## ‚úÖ CHECKLIST DE C√ìDIGO

Antes de cada commit, verifica:

- [ ] ¬øAPI Routes marcadas con `export const dynamic = 'force-dynamic'`?
- [ ] ¬øNo hay operaciones que excedan 60 segundos?
- [ ] ¬øNo estoy guardando archivos en el filesystem (excepto `/tmp` temporal)?
- [ ] ¬øValid√© inputs con Zod/Yup?
- [ ] ¬øVerifiqu√© autenticaci√≥n con `getServerSession`?
- [ ] ¬øUs√© tipos de `@/types/prisma-types` en lugar de `@prisma/client`?
- [ ] ¬øOptimic√© imports (no importar librer√≠as pesadas innecesariamente)?
- [ ] ¬øAgregu√© logging para debugging?
- [ ] ¬øManej√© errores con try/catch?
- [ ] ¬øRetorn√© c√≥digos HTTP apropiados (200, 201, 400, 401, 500)?

---

## üöÄ COMANDOS √öTILES

```bash
# Desarrollo
yarn dev

# Build local (tarda por Prisma, preferir deploy en Vercel)
yarn build

# Testing
yarn test:unit        # Vitest
yarn test:e2e         # Playwright
yarn test:e2e:ui      # Playwright UI

# Database
yarn prisma studio    # UI para DB
yarn prisma migrate dev
yarn db:backup        # Backup script

# Linting y formato
yarn lint:fix
yarn format

# An√°lisis
yarn analyze          # Bundle size
```

---

## üéì RECURSOS Y DOCUMENTACI√ìN

- **Next.js 15**: https://nextjs.org/docs
- **Prisma**: https://www.prisma.io/docs
- **Shadcn/ui**: https://ui.shadcn.com
- **Vercel Limits**: https://vercel.com/docs/limits
- **React Query**: https://tanstack.com/query/latest
- **Zod**: https://zod.dev

---

## üí° FILOSOF√çA DE DESARROLLO

1. **Simplicidad sobre complejidad**: C√≥digo claro > C√≥digo "inteligente"
2. **Serverless First**: Dise√±ar para funciones ef√≠meras y stateless
3. **Type Safety**: TypeScript + Zod para prevenir errores en runtime
4. **Performance**: Lazy loading, caching, optimizaci√≥n de queries
5. **DX (Developer Experience)**: C√≥digo auto-documentado y f√°cil de mantener
6. **Seguridad**: Nunca confiar en inputs del cliente
7. **Monitoreo**: Logging y error tracking desde el d√≠a 1

---

**√öltima actualizaci√≥n**: 29 de diciembre de 2025
**Versi√≥n**: 1.0.0
**Mantenido por**: Equipo Inmova
